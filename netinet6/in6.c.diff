--- in6.c.orig	2005-02-10 21:46:02.000000000 +0900
+++ in6.c	2005-03-06 11:22:36.000000000 +0900
@@ -688,7 +688,7 @@
 	struct rtentry *rt;
 	int delay;
 	char ip6buf[INET6_ADDRSTRLEN];
-
+	dprint(("in6_update_ifa Start\n"));
 	/* Validate parameters */
 	if (ifp == NULL || ifra == NULL) /* this maybe redundant */
 		return (EINVAL);
@@ -861,6 +861,7 @@
 	 * install the new destination.  Note that the interface must be
 	 * p2p or loopback (see the check above.)
 	 */
+	dprint(("in6_update_ifa: testprint 1\n"));
 	if (dst6.sin6_family == AF_INET6 &&
 	    !IN6_ARE_ADDR_EQUAL(&dst6.sin6_addr, &ia->ia_dstaddr.sin6_addr)) {
 		int e;
@@ -881,6 +882,7 @@
 	 * to see if the address is deprecated or invalidated, but initialize
 	 * these members for applications.
 	 */
+	dprint(("in6_update_ifa: testprint 2\n"));
 	ia->ia6_lifetime = ifra->ifra_lifetime;
 	if (ia->ia6_lifetime.ia6t_vltime != ND6_INFINITE_LIFETIME) {
 		ia->ia6_lifetime.ia6t_expire =
@@ -894,17 +896,24 @@
 		ia->ia6_lifetime.ia6t_preferred = 0;
 
 	/* reset the interface and routing table appropriately. */
-	if ((error = in6_ifinit(ifp, ia, &ifra->ifra_addr, hostIsNew)) != 0)
+	dprint(("in6_update_ifa: testprint 3\n"));
+	if ((error = in6_ifinit(ifp, ia, &ifra->ifra_addr, hostIsNew)) != 0){
+		dprint(("in6_update_ifa: goto unlink\n"));
 		goto unlink;
+	}
 
 	/*
 	 * configure address flags.
 	 */
+	dprint(("in6_update_ifa: testprint 4\n"));
+	dprint(("in6_update_ifa: ifra[%p]\n",ifra));
+	dprint(("in6_update_ifa: ifra->ifra_flags[%d]\n",ifra->ifra_flags));
 	ia->ia6_flags = ifra->ifra_flags;
 	/*
 	 * backward compatibility - if IN6_IFF_DEPRECATED is set from the
 	 * userland, make it deprecated.
 	 */
+	dprint(("in6_update_ifa: testprint 5\n"));
 	if ((ifra->ifra_flags & IN6_IFF_DEPRECATED) != 0) {
 		ia->ia6_lifetime.ia6t_pltime = 0;
 		ia->ia6_lifetime.ia6t_preferred = time_second;
@@ -914,6 +923,7 @@
 	 * so that corresponding MLD responses would not have a tentative
 	 * source address.
 	 */
+	dprint(("in6_update_ifa: testprint 6\n"));
 	ia->ia6_flags &= ~IN6_IFF_DUPLICATED;	/* safety */
 	if (hostIsNew && in6if_do_dad(ifp))
 		ia->ia6_flags |= IN6_IFF_TENTATIVE;
@@ -1138,6 +1148,7 @@
 
 	KASSERT(hostIsNew, ("in6_update_ifa: !hostIsNew"));
 	ifa_free(&ia->ia_ifa);
+	dprint(("in6_update_ifa End\n"));
 	return (error);
 
   unlink:
@@ -1149,12 +1160,14 @@
 		in6_unlink_ifa(ia, ifp);
 		ifa_free(&ia->ia_ifa);
 	}
+	dprint(("in6_update_ifa End case unlink\n"));
 	return (error);
 
   cleanup:
 	KASSERT(hostIsNew, ("in6_update_ifa: cleanup: !hostIsNew"));
 	ifa_free(&ia->ia_ifa);
 	in6_purgeaddr(&ia->ia_ifa);
+	dprint(("in6_update_ifa End case cleanup\n"));
 	return error;
 }
 
@@ -1166,6 +1179,7 @@
 	struct in6_multi_mship *imm;
 	struct sockaddr_in6 mltaddr, mltmask;
 	struct rtentry rt0;
+	//struct ptree_node rn0;
 	struct sockaddr_dl gateway;
 	struct sockaddr_in6 mask, addr;
 	int plen, error;
@@ -1217,6 +1231,8 @@
 	gateway.sdl_alen = ifp->if_addrlen;
 	/* */
 	bzero(&rt0, sizeof(rt0));
+	//bzero(&rn0, sizeof(rn0));
+	//rt0.rt_nodes = &rn0;
 	rt0.rt_gateway = (struct sockaddr *)&gateway;
 	memcpy(&mask, &ia->ia_prefixmask, sizeof(ia->ia_prefixmask));
 	memcpy(&addr, &ia->ia_addr, sizeof(ia->ia_addr));
@@ -1698,6 +1714,7 @@
 	int	error = 0, plen, ifacount = 0;
 	int	s = splimp();
 	struct ifaddr *ifa;
+	dprint(("in6_ifinit Start\n"));
 
 	/*
 	 * Give the interface a chance to initialize
@@ -1735,6 +1752,7 @@
 	 * XXX: the logic below rejects assigning multiple addresses on a p2p
 	 * interface that share the same destination.
 	 */
+	dprint(("in6_ifinit: testprint 1\n"));
 	plen = in6_mask2len(&ia->ia_prefixmask.sin6_addr, NULL); /* XXX */
 	if (!(ia->ia_flags & IFA_ROUTE) && plen == 128 &&
 	    ia->ia_dstaddr.sin6_family == AF_INET6) {
@@ -1753,6 +1771,7 @@
 	/*
 	 * add a loopback route to self
 	 */
+	dprint(("in6_ifinit: testprint 2\n"));
 	if (!(ia->ia_flags & IFA_ROUTE)
 	    && (V_nd6_useloopback
 		|| (ifp->if_flags & IFF_LOOPBACK))) {
@@ -1761,9 +1780,11 @@
 	}
 
 	/* Add ownaddr as loopback rtentry, if necessary (ex. on p2p link). */
+	dprint(("in6_ifinit: testprint 3\n"));
 	if (newhost) {
 		struct llentry *ln;
 		struct rtentry rt;
+		//struct ptree_node rn;
 		struct sockaddr_dl gateway;
 		struct sockaddr_in6 mask, addr;
 
@@ -1776,6 +1797,7 @@
 		ln = lla_lookup(LLTABLE6(ifp), (LLE_CREATE | LLE_IFADDR | LLE_EXCLUSIVE),
 		    (struct sockaddr *)&ia->ia_addr);
 		IF_AFDATA_UNLOCK(ifp);
+		dprint(("in6_ifinit: testprint 4\n"));
 		if (ln != NULL) {
 			ln->la_expire = 0;  /* for IPv6 this means permanent */
 			ln->ln_state = ND6_LLINFO_REACHABLE;
@@ -1791,8 +1813,11 @@
 			/* */
 			LLE_WUNLOCK(ln);
 		}
+		dprint(("in6_ifinit: testprint 5\n"));
 
 		bzero(&rt, sizeof(rt));
+		//bzero(&rn, sizeof(rn));
+		//rt.rt_nodes = &rn;
 		rt.rt_gateway = (struct sockaddr *)&gateway;
 		memcpy(&mask, &ia->ia_prefixmask, sizeof(ia->ia_prefixmask));
 		memcpy(&addr, &ia->ia_addr, sizeof(ia->ia_addr));
@@ -1802,6 +1827,7 @@
 		rt_newaddrmsg(RTM_ADD, &ia->ia_ifa, 0, &rt);
 	}
 
+	dprint(("in6_ifinit End\n"));
 	return (error);
 }
 
