--- in6.c.orig	2005-02-10 21:46:02.000000000 +0900
+++ in6.c	2005-03-06 10:39:09.000000000 +0900
@@ -688,7 +688,7 @@
 	struct rtentry *rt;
 	int delay;
 	char ip6buf[INET6_ADDRSTRLEN];
-
+	dprint(("in6_update_ifa Start\n"));
 	/* Validate parameters */
 	if (ifp == NULL || ifra == NULL) /* this maybe redundant */
 		return (EINVAL);
@@ -996,6 +996,7 @@
 		 * actually do not need the routes, since they usually specify
 		 * the outgoing interface.
 		 */
+		dprint(("in6_update_ifa: testprint 1\n"));
 		rt = rtalloc1((struct sockaddr *)&mltaddr, 0, 0UL);
 		if (rt) {
 			/* XXX: only works in !SCOPEDROUTING case. */
@@ -1016,6 +1017,7 @@
 		} else {
 			RTFREE_LOCKED(rt);
 		}
+		dprint(("in6_update_ifa: testprint 2\n"));
 
 		imm = in6_joingroup(ifp, &mltaddr.sin6_addr, &error, 0);
 		if (!imm) {
@@ -1031,6 +1033,7 @@
 		/*
 		 * join node information group address
 		 */
+		dprint(("in6_update_ifa: testprint 3\n"));
 		delay = 0;
 		if ((flags & IN6_IFAUPDATE_DADDELAY)) {
 			/*
@@ -1060,6 +1063,7 @@
 		 * join interface-local all-nodes address.
 		 * (ff01::1%ifN, and ff01::%ifN/32)
 		 */
+		dprint(("in6_update_ifa: testprint 4\n"));
 		mltaddr.sin6_addr = in6addr_nodelocal_allnodes;
 		if ((error = in6_setscope(&mltaddr.sin6_addr, ifp, NULL))
 		    != 0)
@@ -1102,6 +1106,7 @@
 	 * XXX It may be of use, if we can administratively
 	 * disable DAD.
 	 */
+	dprint(("in6_update_ifa: testprint 5\n"));
 	if (in6if_do_dad(ifp) && ((ifra->ifra_flags & IN6_IFF_NODAD) == 0) &&
 	    (ia->ia6_flags & IN6_IFF_TENTATIVE))
 	{
@@ -1138,6 +1143,7 @@
 
 	KASSERT(hostIsNew, ("in6_update_ifa: !hostIsNew"));
 	ifa_free(&ia->ia_ifa);
+	dprint(("in6_update_ifa End\n"));
 	return (error);
 
   unlink:
@@ -1149,12 +1155,14 @@
 		in6_unlink_ifa(ia, ifp);
 		ifa_free(&ia->ia_ifa);
 	}
+	dprint(("in6_update_ifa End case unlink\n"));
 	return (error);
 
   cleanup:
 	KASSERT(hostIsNew, ("in6_update_ifa: cleanup: !hostIsNew"));
 	ifa_free(&ia->ia_ifa);
 	in6_purgeaddr(&ia->ia_ifa);
+	dprint(("in6_update_ifa End case cleanup\n"));
 	return error;
 }
 
@@ -1166,6 +1174,7 @@
 	struct in6_multi_mship *imm;
 	struct sockaddr_in6 mltaddr, mltmask;
 	struct rtentry rt0;
+	//struct ptree_node rn0;
 	struct sockaddr_dl gateway;
 	struct sockaddr_in6 mask, addr;
 	int plen, error;
@@ -1217,6 +1226,8 @@
 	gateway.sdl_alen = ifp->if_addrlen;
 	/* */
 	bzero(&rt0, sizeof(rt0));
+	//bzero(&rn0, sizeof(rn0));
+	//rt0.rt_nodes = &rn0;
 	rt0.rt_gateway = (struct sockaddr *)&gateway;
 	memcpy(&mask, &ia->ia_prefixmask, sizeof(ia->ia_prefixmask));
 	memcpy(&addr, &ia->ia_addr, sizeof(ia->ia_addr));
@@ -1764,6 +1775,7 @@
 	if (newhost) {
 		struct llentry *ln;
 		struct rtentry rt;
+		//struct ptree_node rn;
 		struct sockaddr_dl gateway;
 		struct sockaddr_in6 mask, addr;
 
@@ -1793,6 +1805,8 @@
 		}
 
 		bzero(&rt, sizeof(rt));
+		//bzero(&rn, sizeof(rn));
+		//rt.rt_nodes = &rn;
 		rt.rt_gateway = (struct sockaddr *)&gateway;
 		memcpy(&mask, &ia->ia_prefixmask, sizeof(ia->ia_prefixmask));
 		memcpy(&addr, &ia->ia_addr, sizeof(ia->ia_addr));
