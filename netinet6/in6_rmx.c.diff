--- in6_rmx.c.orig	2005-01-19 12:54:14.000000000 +0900
+++ in6_rmx.c	2005-02-08 08:28:09.000000000 +0900
@@ -113,21 +113,26 @@
 
 #define RTPRF_OURS		RTF_PROTO3	/* set on routes we manage */
 
+#define DEBUG 1
+#define dprint(x) { if(DEBUG) printf x; }
+
 /*
  * Do what we need to do when inserting a route.
  */
-static struct radix_node *
-in6_addroute(void *v_arg, void *n_arg, struct radix_node_head *head,
-    struct radix_node *treenodes)
+static struct ptree_node *
+in6_addroute(void *v_arg, void *n_arg, struct ptree_node_head *head,
+				struct ptree_node *rt_node)
 {
-	struct rtentry *rt = (struct rtentry *)treenodes;
+	dprint(("in6_addroute Start\n"));
+	struct rtentry *rt = (struct rtentry *)(&rt_node);
+	dprint(("in6_addroute: test print 1\n"));
 	struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)rt_key(rt);
-	struct radix_node *ret;
+	dprint(("in6_addroute: test print 2\n"));
+	struct ptree_node *ret;
 
 	RADIX_NODE_HEAD_WLOCK_ASSERT(head);
 	if (IN6_IS_ADDR_MULTICAST(&sin6->sin6_addr))
 		rt->rt_flags |= RTF_MULTICAST;
-
 	/*
 	 * A little bit of help for both IPv6 output and input:
 	 *   For local addresses, we make sure that RTF_LOCAL is set,
@@ -142,6 +147,7 @@
 	 * XXX
 	 * should elaborate the code.
 	 */
+	dprint(("in6_addroute: test print 3\n"));
 	if (rt->rt_flags & RTF_HOST) {
 		if (IN6_ARE_ADDR_EQUAL(&satosin6(rt->rt_ifa->ifa_addr)
 					->sin6_addr,
@@ -149,11 +155,14 @@
 			rt->rt_flags |= RTF_LOCAL;
 		}
 	}
+	dprint(("in6_addroute: test print 4\n"));
 
 	if (!rt->rt_rmx.rmx_mtu && rt->rt_ifp)
 		rt->rt_rmx.rmx_mtu = IN6_LINKMTU(rt->rt_ifp);
-
-	ret = rn_addroute(v_arg, n_arg, head, treenodes);
+	
+	dprint(("in6_addroute: test print 5\n"));
+	ret = ptree_addroute(v_arg, n_arg, head, rt_node);
+	dprint(("in6_addroute: test print 6\n"));
 	if (ret == NULL) {
 		struct rtentry *rt2;
 		/*
@@ -179,6 +188,7 @@
 			RTFREE_LOCKED(rt2);
 		}
 	}
+	dprint(("in6_addroute End\n"));
 	return (ret);
 }
 
@@ -187,10 +197,11 @@
  * were managing the route, stop doing so and set the expiration timer
  * back off again.
  */
-static struct radix_node *
-in6_matroute(void *v_arg, struct radix_node_head *head)
+static struct ptree_node *
+in6_matroute(void *v_arg, struct ptree_node_head *head)
 {
-	struct radix_node *rn = rn_match(v_arg, head);
+	dprint(("in6_matroute Start\n"));
+	struct ptree_node *rn = ptree_matchaddr(v_arg, head);
 	struct rtentry *rt = (struct rtentry *)rn;
 
 	if (rt && rt->rt_refcnt == 0) { /* this is first reference */
@@ -199,6 +210,7 @@
 			rt->rt_rmx.rmx_expire = 0;
 		}
 	}
+	dprint(("in6_matroute End\n"));
 	return rn;
 }
 
@@ -222,7 +234,7 @@
     &VNET_NAME(rtq_toomany6) , 0, "");
 
 struct rtqk_arg {
-	struct radix_node_head *rnh;
+	struct ptree_node_head *rnh;
 	int mode;
 	int updating;
 	int draining;
@@ -237,8 +249,9 @@
  * nothing has a timeout longer than the current value of rtq_reallyold6.
  */
 static int
-in6_rtqkill(struct radix_node *rn, void *rock)
+in6_rtqkill(struct ptree_node *rn, void *rock)
 {
+	dprint(("in6_rtqkill Start\n"));
 	struct rtqk_arg *ap = rock;
 	struct rtentry *rt = (struct rtentry *)rn;
 	int err;
@@ -273,6 +286,7 @@
 		}
 	}
 
+	dprint(("in6_rtqkill End\n"));
 	return 0;
 }
 
@@ -286,8 +300,9 @@
 static void
 in6_rtqtimo(void *rock)
 {
+	dprint(("in6_rtqtimo Start\n"));
 	CURVNET_SET_QUIET((struct vnet *) rock);
-	struct radix_node_head *rnh;
+	struct ptree_node_head *rnh;
 	struct rtqk_arg arg;
 	struct timeval atv;
 	static time_t last_adjusted_timeout = 0;
@@ -295,6 +310,7 @@
 	rnh = rt_tables_get_rnh(0, AF_INET6);
 	if (rnh == NULL) {
 		CURVNET_RESTORE();
+		dprint(("in6_rtqtimo End 1\n"));
 		return;
 	}
 	arg.found = arg.killed = 0;
@@ -337,13 +353,14 @@
 	atv.tv_sec = arg.nextstop - time_uptime;
 	callout_reset(&V_rtq_timer6, tvtohz(&atv), in6_rtqtimo, rock);
 	CURVNET_RESTORE();
+	dprint(("in6_rtqtimo End 2\n"));
 }
 
 /*
  * Age old PMTUs.
  */
 struct mtuex_arg {
-	struct radix_node_head *rnh;
+	struct ptree_node_head *rnh;
 	time_t nextstop;
 };
 
@@ -351,8 +368,9 @@
 #define	V_rtq_mtutimer			VNET(rtq_mtutimer)
 
 static int
-in6_mtuexpire(struct radix_node *rn, void *rock)
+in6_mtuexpire(struct ptree_node *rn, void *rock)
 {
+	dprint(("in6_mtuexpire Start\n"));
 	struct rtentry *rt = (struct rtentry *)rn;
 	struct mtuex_arg *ap = rock;
 
@@ -369,6 +387,7 @@
 		}
 	}
 
+	dprint(("in6_mtuexpire End\n"));
 	return 0;
 }
 
@@ -377,8 +396,9 @@
 static void
 in6_mtutimo(void *rock)
 {
+	dprint(("in6_mtutimo Start\n"));
 	CURVNET_SET_QUIET((struct vnet *) rock);
-	struct radix_node_head *rnh;
+	struct ptree_node_head *rnh;
 	struct mtuex_arg arg;
 	struct timeval atv;
 
@@ -402,6 +422,7 @@
 	}
 	callout_reset(&V_rtq_mtutimer, tvtohz(&atv), in6_mtutimo, rock);
 	CURVNET_RESTORE();
+	dprint(("in6_mtutimo End\n"));
 }
 
 /*
@@ -414,9 +435,10 @@
 int
 in6_inithead(void **head, int off)
 {
-	struct radix_node_head *rnh;
+	dprint(("in6_inithead Start off = %d\n",off));
+	struct ptree_node_head *rnh;
 
-	if (!rn_inithead(head, offsetof(struct sockaddr_in6, sin6_addr) << 3))
+	if (!ptree_inithead(head, offsetof(struct sockaddr_in6, sin6_addr) << 3))
 		return 0;		/* See above */
 
 	if (off == 0)		/* See above */
@@ -435,6 +457,7 @@
 	callout_init(&V_rtq_mtutimer, CALLOUT_MPSAFE);
 	in6_rtqtimo(curvnet);	/* kick off timeout first time */
 	in6_mtutimo(curvnet);	/* kick off timeout first time */
+	dprint(("in6_inithead End\n"));
 	return 1;
 }
 
@@ -448,3 +471,5 @@
 	return (1);
 }
 #endif
+#undef dprint
+#undef DEBUG
