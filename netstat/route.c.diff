--- route.c.org	2010-12-26 14:51:50.000000000 +0900
+++ route.c	2010-12-26 16:34:22.000000000 +0900
@@ -51,7 +51,8 @@
 #include <net/if_var.h>
 #include <net/if_dl.h>
 #include <net/if_types.h>
-#include <net/radix.h>
+#include <net/ptree.h>
+#include <net/ptree_mpath.h>
 #include <net/route.h>
 
 #include <netinet/in.h>
@@ -120,19 +121,18 @@
 int	fibnum;
 int	do_rtent = 0;
 struct	rtentry rtentry;
-struct	radix_node rnode;
-struct	radix_mask rmask;
-struct	radix_node_head **rt_tables;
+struct	ptree_node rnode;
+struct	ptree_node_head **rt_tables;
 
 int	NewTree = 0;
 
 struct	timespec uptime;
 
 static struct sockaddr *kgetsa(struct sockaddr *);
-static void size_cols(int ef, struct radix_node *rn);
-static void size_cols_tree(struct radix_node *rn);
+static void size_cols(int ef, struct ptree_node *rn);
+static void size_cols_tree(struct ptree_node *rn);
 static void size_cols_rtentry(struct rtentry *rt);
-static void p_tree(struct radix_node *);
+static void p_tree(struct ptree_node *);
 static void p_rtnode(void);
 static void ntreestuff(void);
 static void np_rtentry(struct rt_msghdr *);
@@ -150,7 +150,9 @@
 void
 routepr(u_long rtree)
 {
-	struct radix_node_head **rnhp, *rnh, head;
+	printf("routepr\n");
+	struct ptree_node_head **rnhp, *rnh, head;
+	struct ptree *pnhp, pnh_head;
 	size_t intsize;
 	int i;
 	int numfibs;
@@ -161,7 +163,7 @@
 	if (sysctlbyname("net.fibs", &numfibs, &intsize, NULL, 0) == -1)
 		numfibs = 1;
 	rt_tables = calloc(numfibs * (AF_MAX+1),
-	    sizeof(struct radix_node_head *));
+	    sizeof(struct ptree_node_head *));
 	if (rt_tables == NULL)
 		err(EX_OSERR, "memory allocation failed");
 	/*
@@ -183,7 +185,7 @@
 		}
 
 		if (kread((u_long)(rtree), (char *)(rt_tables), (numfibs *
-		    (AF_MAX+1) * sizeof(struct radix_node_head *))) != 0)
+		    (AF_MAX+1) * sizeof(struct ptree_node_head *))) != 0)
 			return;
 		for (i = 0; i <= AF_MAX; i++) {
 			int tmpfib;
@@ -191,7 +193,7 @@
 				tmpfib = 0;
 			else
 				tmpfib = fibnum;
-			rnhp = (struct radix_node_head **)*rt_tables;
+			rnhp = (struct ptree_node_head **)*rt_tables;
 			/* Calculate the in-kernel address. */
 			rnhp += tmpfib * (AF_MAX+1) + i;
 			/* Read the in kernel rhn pointer. */
@@ -202,17 +204,22 @@
 			/* Read the rnh data. */
 			if (kget(rnh, head) != 0)
 				continue;
+			
+			pnhp = head.pnh_treetop;
+			/* Read the pnh_head data. */
+			if (kget(pnhp,pnh_head) != 0)
+				continue;
 			if (i == AF_UNSPEC) {
 				if (Aflag && af == 0) {
 					printf("Netmasks:\n");
-					p_tree(head.rnh_treetop);
+					p_tree(pnh_head.top);
 				}
 			} else if (af == AF_UNSPEC || af == i) {
-				size_cols(i, head.rnh_treetop);
+				size_cols(i, pnh_head.top);
 				pr_family(i);
 				do_rtent = 1;
 				pr_rthdr(i);
-				p_tree(head.rnh_treetop);
+				p_tree(pnh_head.top);
 			}
 		}
 	}
@@ -283,8 +290,9 @@
 static int wid_expire;
 
 static void
-size_cols(int ef __unused, struct radix_node *rn)
+size_cols(int ef __unused, struct ptree_node *rn)
 {
+	printf("size_cols\n");
 	wid_dst = WID_DST_DEFAULT(ef);
 	wid_gw = WID_GW_DEFAULT(ef);
 	wid_flags = 6;
@@ -299,40 +307,40 @@
 }
 
 static void
-size_cols_tree(struct radix_node *rn)
+size_cols_tree(struct ptree_node *rn)
 {
-again:
+	printf("size_cols_tree\n");
 	if (kget(rn, rnode) != 0)
 		return;
-	if (!(rnode.rn_flags & RNF_ACTIVE))
+	if(!rn->data)
 		return;
-	if (rnode.rn_bit < 0) {
-		if ((rnode.rn_flags & RNF_ROOT) == 0) {
-			if (kget(rn, rtentry) != 0)
+	else{
+		if (kget(rn->data,rtentry) != 0)
 				return;
 			size_cols_rtentry(&rtentry);
 		}
-		if ((rn = rnode.rn_dupedkey))
-			goto again;
-	} else {
-		rn = rnode.rn_right;
-		size_cols_tree(rnode.rn_left);
+	rn = rnode.child[1];
+	size_cols_tree(rnode.child[0]);
 		size_cols_tree(rn);
 	}
-}
 
 static void
 size_cols_rtentry(struct rtentry *rt)
 {
+	printf("size_cols_rtentry\n");
 	static struct ifnet ifnet, *lastif;
 	static char buffer[100];
 	const char *bp;
 	struct sockaddr *sa;
 	sa_u addr, mask;
 	int len;
+	struct ptree_node rn;
+
 
 	bzero(&addr, sizeof(addr));
-	if ((sa = kgetsa(rt_key(rt))))
+	if (kget(rt->rt_nodes,rn) != 0)
+		return;
+	if ((sa = kgetsa((struct sockaddr *)rn.key)))
 		bcopy(sa, &addr, sa->sa_len);
 	bzero(&mask, sizeof(mask));
 	if (rt_mask(rt) && (sa = kgetsa(rt_mask(rt))))
@@ -382,14 +390,13 @@
 	}
 }
 
-
 /*
  * Print header for routing table columns.
  */
 void
 pr_rthdr(int af1)
 {
-
+	printf("pr_rthdr\n");
 	if (Aflag)
 		printf("%-8.8s ","Address");
 	if (af1 == AF_INET || Wflag) {
@@ -426,7 +433,7 @@
 static struct sockaddr *
 kgetsa(struct sockaddr *dst)
 {
-
+	printf("kgetsa\n");
 	if (kget(dst, pt_u.u_sa) != 0)
 		return (NULL);
 	if (pt_u.u_sa.sa_len > sizeof (pt_u.u_sa))
@@ -435,90 +442,60 @@
 }
 
 static void
-p_tree(struct radix_node *rn)
+p_tree(struct ptree_node *rn)
 {
-
-again:
+	printf("p_tree\n");
+#if 0
+	int i;
+	struct rtentry **rt0;
+#endif
 	if (kget(rn, rnode) != 0)
 		return;
-	if (!(rnode.rn_flags & RNF_ACTIVE))
-		return;
-	if (rnode.rn_bit < 0) {
 		if (Aflag)
 			printf("%-8.8lx ", (u_long)rn);
-		if (rnode.rn_flags & RNF_ROOT) {
-			if (Aflag)
-				printf("(root node)%s",
-				    rnode.rn_dupedkey ? " =>\n" : "\n");
-		} else if (do_rtent) {
-			if (kget(rn, rtentry) == 0) {
+	if (do_rtent) {
+		if (kget(rnode.data, rtentry) == 0) {
 				p_rtentry(&rtentry);
 				if (Aflag)
 					p_rtnode();
 			}
+#if 0
+		/* multipath */
+		if(rtentry.mpath_array){
+			if (kget(rtentry.mpath_array, rt0) == 0) {
+				for(i=1;rt0[i]==NULL;i++)
+					p_rtentry(rt0[i]);
+			}
+		}
+#endif
 		} else {
-			p_sockaddr(kgetsa((struct sockaddr *)rnode.rn_key),
+		p_sockaddr(kgetsa((struct sockaddr *)rnode.key),
 				   NULL, 0, 44);
 			putchar('\n');
 		}
-		if ((rn = rnode.rn_dupedkey))
-			goto again;
-	} else {
 		if (Aflag && do_rtent) {
 			printf("%-8.8lx ", (u_long)rn);
 			p_rtnode();
 		}
-		rn = rnode.rn_right;
-		p_tree(rnode.rn_left);
+	rn = rnode.child[1];
+	p_tree(rnode.child[0]);
 		p_tree(rn);
 	}
-}
 
 char	nbuf[20];
 
 static void
 p_rtnode(void)
 {
-	struct radix_mask *rm = rnode.rn_mklist;
-
-	if (rnode.rn_bit < 0) {
-		if (rnode.rn_mask) {
-			printf("\t  mask ");
-			p_sockaddr(kgetsa((struct sockaddr *)rnode.rn_mask),
-				   NULL, 0, -1);
-		} else if (rm == 0)
-			return;
-	} else {
-		sprintf(nbuf, "(%d)", rnode.rn_bit);
-		printf("%6.6s %8.8lx : %8.8lx", nbuf, (u_long)rnode.rn_left, (u_long)rnode.rn_right);
-	}
-	while (rm) {
-		if (kget(rm, rmask) != 0)
-			break;
-		sprintf(nbuf, " %d refs, ", rmask.rm_refs);
-		printf(" mk = %8.8lx {(%d),%s",
-			(u_long)rm, -1 - rmask.rm_bit, rmask.rm_refs ? nbuf : " ");
-		if (rmask.rm_flags & RNF_NORMAL) {
-			struct radix_node rnode_aux;
-			printf(" <normal>, ");
-			if (kget(rmask.rm_leaf, rnode_aux) == 0)
-				p_sockaddr(kgetsa((struct sockaddr *)rnode_aux.rn_mask),
-				    NULL, 0, -1);
-			else
-				p_sockaddr(NULL, NULL, 0, -1);
-		} else
-		    p_sockaddr(kgetsa((struct sockaddr *)rmask.rm_mask),
-				NULL, 0, -1);
-		putchar('}');
-		if ((rm = rmask.rm_mklist))
-			printf(" ->");
-	}
-	putchar('\n');
+		printf("p_rtnode\n");
+		sprintf(nbuf, "(%d)", rnode.keylen);
+		printf("%6.6s %8.8lx : %8.8lx", nbuf, (u_long)rnode.child[0], (u_long)rnode.child[1]);
 }
 
 static void
 ntreestuff(void)
 {
+	printf("ntreestuff\n");
 	size_t needed;
 	int mib[6];
 	char *buf, *next, *lim;
@@ -550,6 +527,7 @@
 static void
 np_rtentry(struct rt_msghdr *rtm)
 {
+	printf("np_rtentry\n");
 	struct sockaddr *sa = (struct sockaddr *)(rtm + 1);
 #ifdef notdef
 	static int masks_done, banner_printed;
@@ -589,6 +567,7 @@
 static void
 p_sockaddr(struct sockaddr *sa, struct sockaddr *mask, int flags, int width)
 {
+	printf("p_sockaddr\n");
 	const char *cp;
 
 	cp = fmt_sockaddr(sa, mask, flags);
@@ -606,6 +585,7 @@
 static const char *
 fmt_sockaddr(struct sockaddr *sa, struct sockaddr *mask, int flags)
 {
+	printf("fmt_sockaddr\n");
 	static char workbuf[128];
 	const char *cp;
 
@@ -744,6 +724,7 @@
 static const char *
 fmt_flags(int f)
 {
+	printf("fmt_flags\n");
 	static char name[33];
 	char *flags;
 	struct bits *p = bits;
@@ -758,14 +739,18 @@
 static void
 p_rtentry(struct rtentry *rt)
 {
+	printf("p_rtentry\n");
 	static struct ifnet ifnet, *lastif;
 	static char buffer[128];
 	static char prettyname[128];
 	struct sockaddr *sa;
 	sa_u addr, mask;
+	struct ptree_node rn;
 
 	bzero(&addr, sizeof(addr));
-	if ((sa = kgetsa(rt_key(rt))))
+	if (kget(rt->rt_nodes,rn) != 0)
+		return;
+	if ((sa = kgetsa((struct sockaddr *)rn.key)))
 		bcopy(sa, &addr, sa->sa_len);
 	bzero(&mask, sizeof(mask));
 	if (rt_mask(rt) && (sa = kgetsa(rt_mask(rt))))
@@ -801,8 +786,6 @@
 			    rt->rt_rmx.rmx_expire - uptime.tv_sec) > 0)
 				printf(" %*d", wid_expire, (int)expire_time);
 		}
-		if (rt->rt_nodes[0].rn_dupedkey)
-			printf(" =>");
 	}
 	putchar('\n');
 }
@@ -810,6 +793,7 @@
 char *
 routename(in_addr_t in)
 {
+	printf("routename\n");
 	char *cp;
 	static char line[MAXHOSTNAMELEN];
 	struct hostent *hp;
@@ -842,6 +826,7 @@
 static void
 domask(char *dst, in_addr_t addr __unused, u_long mask)
 {
+	printf("domask\n");
 	int b, i;
 
 	if (mask == 0 || (!numeric_addr && NSHIFT(mask) != 0)) {
@@ -874,6 +859,7 @@
 char *
 netname(in_addr_t in, u_long mask)
 {
+	printf("netname\n");
 	char *cp = 0;
 	static char line[MAXHOSTNAMELEN];
 	struct netent *np = 0;
@@ -902,6 +888,7 @@
 const char *
 netname6(struct sockaddr_in6 *sa6, struct in6_addr *mask)
 {
+	printf("netname6\n");
 	static char line[MAXHOSTNAMELEN];
 	u_char *p = (u_char *)mask;
 	u_char *lim;
@@ -964,6 +951,7 @@
 char *
 routename6(struct sockaddr_in6 *sa6)
 {
+	printf("routename6\n");
 	static char line[MAXHOSTNAMELEN];
 	int flag = 0;
 	/* use local variable for safety */
@@ -990,6 +978,7 @@
 void
 rt_stats(u_long rtsaddr, u_long rttaddr)
 {
+	printf("rt_stats\n");
 	struct rtstat rtstat;
 	int rttrash;
 
@@ -1023,6 +1012,7 @@
 char *
 ipx_print(struct sockaddr *sa)
 {
+	printf("ipx_print\n");
 	u_short port;
 	struct servent *sp = 0;
 	const char *net = "", *host = "";
@@ -1092,6 +1082,7 @@
 char *
 ipx_phost(struct sockaddr *sa)
 {
+	printf("ipx_phost\n");
 	struct sockaddr_ipx *sipx = (struct sockaddr_ipx *)sa;
 	struct sockaddr_ipx work;
 	static union ipx_net ipx_zeronet;
