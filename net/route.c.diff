--- route.c.orig	2010-10-15 13:30:11.000000000 +0900
+++ route.c	2010-10-17 08:35:15.000000000 +0900
@@ -38,6 +38,7 @@
 #include "opt_route.h"
 #include "opt_mrouting.h"
 #include "opt_mpath.h"
+#include "opt_ptree.h"
 
 #include <sys/param.h>
 #include <sys/systm.h>
@@ -85,10 +86,10 @@
  */
 u_int rt_add_addr_allfibs = 1;
 SYSCTL_INT(_net, OID_AUTO, add_addr_allfibs, CTLFLAG_RW,
-    &rt_add_addr_allfibs, 0, "");
+		&rt_add_addr_allfibs, 0, "");
 TUNABLE_INT("net.add_addr_allfibs", &rt_add_addr_allfibs);
 
-VNET_DEFINE(struct radix_node_head *, rt_tables);
+VNET_DEFINE(struct ptree *, rt_tables);
 static VNET_DEFINE(uma_zone_t, rtzone);		/* Routing table UMA zone. */
 VNET_DEFINE(int, rttrash);		/* routes not in table but not freed */
 VNET_DEFINE(struct rtstat, rtstat);
@@ -99,7 +100,7 @@
 #define	V_rtstat	VNET(rtstat)
 
 static void rt_maskedcopy(struct sockaddr *,
-	    struct sockaddr *, struct sockaddr *);
+		struct sockaddr *, struct sockaddr *);
 
 /* compare two sockaddr structures */
 #define	sa_equal(a1, a2) (bcmp((a1), (a2), (a1)->sa_len) == 0)
@@ -125,42 +126,53 @@
 /*
  * handler for net.my_fibnum
  */
-static int
+	static int
 sysctl_my_fibnum(SYSCTL_HANDLER_ARGS)
 {
-        int fibnum;
-        int error;
- 
-        fibnum = curthread->td_proc->p_fibnum;
-        error = sysctl_handle_int(oidp, &fibnum, 0, req);
-        return (error);
+#ifdef DEBUG
+	printf("sysctl_my_fibnum\n");
+#endif
+	int fibnum;
+	int error;
+
+	fibnum = curthread->td_proc->p_fibnum;
+	error = sysctl_handle_int(oidp, &fibnum, 0, req);
+	return (error);
 }
 
 SYSCTL_PROC(_net, OID_AUTO, my_fibnum, CTLTYPE_INT|CTLFLAG_RD,
-            NULL, 0, &sysctl_my_fibnum, "I", "default FIB of caller");
+		NULL, 0, &sysctl_my_fibnum, "I", "default FIB of caller");
 
-static __inline struct radix_node_head **
+	static __inline struct ptree **
 rt_tables_get_rnh_ptr(int table, int fam)
 {
-	struct radix_node_head **rnh;
+#ifdef DEBUG
+	printf("rt_tables_get_rnh_ptr\n");
+	printf("table = %d, fam = %d\n",table,fam);
+#endif
+	struct ptree **rnh;
 
-	KASSERT(table >= 0 && table < rt_numfibs, ("%s: table out of bounds.",
-	    __func__));
+	KASSERT(table >= 0 && table < rt_numfibs, ("%s: table out of bounds.", __func__));
 	KASSERT(fam >= 0 && fam < (AF_MAX+1), ("%s: fam out of bounds.",
-	    __func__));
+				__func__));
 
 	/* rnh is [fib=0][af=0]. */
-	rnh = (struct radix_node_head **)V_rt_tables;
+	rnh = (struct ptree **)V_rt_tables;
+#ifdef DEBUG
+	printf("rnh[fib=0][af=0] = %p\n",rnh);
+#endif
 	/* Get the offset to the requested table and fam. */
 	rnh += table * (AF_MAX+1) + fam;
+#ifdef DEBUG
+	printf("return: rhn = %p\n",rnh);
+#endif
 
 	return (rnh);
 }
 
-struct radix_node_head *
+	struct ptree *
 rt_tables_get_rnh(int table, int fam)
 {
-
 	return (*rt_tables_get_rnh_ptr(table, fam));
 }
 
@@ -168,38 +180,43 @@
  * route initialization must occur before ip6_init2(), which happenas at
  * SI_ORDER_MIDDLE.
  */
-static void
+	static void
 route_init(void)
 {
-
+#ifdef DEBUG
+	printf("route_init\n");
+#endif
 	/* whack the tunable ints into  line. */
 	if (rt_numfibs > RT_MAXFIBS)
 		rt_numfibs = RT_MAXFIBS;
 	if (rt_numfibs == 0)
 		rt_numfibs = 1;
-	rn_init();	/* initialize all zeroes, all ones, mask table */
+	ptree_init();
 }
 SYSINIT(route_init, SI_SUB_PROTO_DOMAIN, SI_ORDER_THIRD, route_init, 0);
 
-static void
+	static void
 vnet_route_init(const void *unused __unused)
 {
+#ifdef DEBUG
+	printf("vnet_route_init\n");
+#endif
 	struct domain *dom;
-	struct radix_node_head **rnh;
+	struct ptree **rnh;
 	int table;
 	int fam;
 
 	V_rt_tables = malloc(rt_numfibs * (AF_MAX+1) *
-	    sizeof(struct radix_node_head *), M_RTABLE, M_WAITOK|M_ZERO);
+			sizeof(struct ptree *), M_RTABLE, M_WAITOK|M_ZERO);
 
 	V_rtzone = uma_zcreate("rtentry", sizeof(struct rtentry), NULL, NULL,
-	    NULL, NULL, UMA_ALIGN_PTR, 0);
+			NULL, NULL, UMA_ALIGN_PTR, 0);
 	for (dom = domains; dom; dom = dom->dom_next) {
 		if (dom->dom_rtattach)  {
 			for  (table = 0; table < rt_numfibs; table++) {
 				if ( (fam = dom->dom_family) == AF_INET ||
-				    table == 0) {
- 			        	/* for now only AF_INET has > 1 table */
+						table == 0) {
+					/* for now only AF_INET has > 1 table */
 					/* XXX MRT 
 					 * rtattach will be also called
 					 * from vfs_export.c but the
@@ -211,7 +228,7 @@
 					if (rnh == NULL)
 						panic("%s: rnh NULL", __func__);
 					dom->dom_rtattach((void **)rnh,
-				    	    dom->dom_rtoffset);
+							dom->dom_rtoffset);
 				} else {
 					break;
 				}
@@ -220,28 +237,31 @@
 	}
 }
 VNET_SYSINIT(vnet_route_init, SI_SUB_PROTO_DOMAIN, SI_ORDER_FOURTH,
-    vnet_route_init, 0);
+		vnet_route_init, 0);
 
 #ifdef VIMAGE
-static void
+	static void
 vnet_route_uninit(const void *unused __unused)
 {
+#ifdef DEBUG
+	printf("vnet_route_uninit\n");
+#endif
 	int table;
 	int fam;
 	struct domain *dom;
-	struct radix_node_head **rnh;
+	struct ptree **rnh;
 
 	for (dom = domains; dom; dom = dom->dom_next) {
 		if (dom->dom_rtdetach) {
 			for (table = 0; table < rt_numfibs; table++) {
 				if ( (fam = dom->dom_family) == AF_INET ||
-				    table == 0) {
+						table == 0) {
 					/* For now only AF_INET has > 1 tbl. */
 					rnh = rt_tables_get_rnh_ptr(table, fam);
 					if (rnh == NULL)
 						panic("%s: rnh NULL", __func__);
 					dom->dom_rtdetach((void **)rnh,
-					    dom->dom_rtoffset);
+							dom->dom_rtoffset);
 				} else {
 					break;
 				}
@@ -250,7 +270,7 @@
 	}
 }
 VNET_SYSUNINIT(vnet_route_uninit, SI_SUB_PROTO_DOMAIN, SI_ORDER_THIRD,
-    vnet_route_uninit, 0);
+		vnet_route_uninit, 0);
 #endif
 
 #ifndef _SYS_SYSPROTO_H_
@@ -258,9 +278,12 @@
 	int     fibnum;
 };
 #endif
-int
+	int
 setfib(struct thread *td, struct setfib_args *uap)
 {
+#ifdef DEBUG
+	printf("setfib\n");
+#endif
 	if (uap->fibnum < 0 || uap->fibnum >= rt_numfibs)
 		return EINVAL;
 	td->td_proc->p_fibnum = uap->fibnum;
@@ -270,21 +293,30 @@
 /*
  * Packet routing routines.
  */
-void
+	void
 rtalloc(struct route *ro)
 {
+#ifdef DEBUG
+	printf("rtalloc\n");
+#endif
 	rtalloc_ign_fib(ro, 0UL, 0);
 }
 
-void
+	void
 rtalloc_fib(struct route *ro, u_int fibnum)
 {
+#ifdef DEBUG
+	printf("rtalloc_fib\n");
+#endif
 	rtalloc_ign_fib(ro, 0UL, fibnum);
 }
 
-void
+	void
 rtalloc_ign(struct route *ro, u_long ignore)
 {
+#ifdef DEBUG
+	printf("rtalloc_ign\n");
+#endif
 	struct rtentry *rt;
 
 	if ((rt = ro->ro_rt) != NULL) {
@@ -298,9 +330,12 @@
 		RT_UNLOCK(ro->ro_rt);
 }
 
-void
+	void
 rtalloc_ign_fib(struct route *ro, u_long ignore, u_int fibnum)
 {
+#ifdef DEBUG
+	printf("rtalloc_ign_fib\n");
+#endif
 	struct rtentry *rt;
 
 	if ((rt = ro->ro_rt) != NULL) {
@@ -320,19 +355,25 @@
  *
  * The returned route, if any, is locked.
  */
-struct rtentry *
+	struct rtentry *
 rtalloc1(struct sockaddr *dst, int report, u_long ignflags)
 {
+#ifdef DEBUG
+	printf("rtalloc1\n");
+#endif
 	return (rtalloc1_fib(dst, report, ignflags, 0));
 }
 
-struct rtentry *
+	struct rtentry *
 rtalloc1_fib(struct sockaddr *dst, int report, u_long ignflags,
-		    u_int fibnum)
+		u_int fibnum)
 {
-	struct radix_node_head *rnh;
+#ifdef DEBUG
+	printf("rtalloc1_fib\n");
+#endif
+	struct ptree *rnh;
 	struct rtentry *rt;
-	struct radix_node *rn;
+	struct ptree_node *rn;
 	struct rtentry *newrt;
 	struct rt_addrinfo info;
 	int err = 0, msgtype = RTM_MISS;
@@ -358,6 +399,9 @@
 		RADIX_NODE_HEAD_LOCK_ASSERT(rnh);
 #endif
 	rn = rnh->rnh_matchaddr(dst, rnh);
+#ifdef DEBUG
+	printf("rtalloc1_fib: matchaddr rn = %p, needlock = %d\n",rn,needlock);
+#endif
 	if (rn && ((rn->rn_flags & RNF_ROOT) == 0)) {
 		newrt = rt = RNTORT(rn);
 		RT_LOCK(newrt);
@@ -368,7 +412,7 @@
 
 	} else if (needlock)
 		RADIX_NODE_HEAD_RUNLOCK(rnh);
-	
+
 	/*
 	 * Either we hit the root or couldn't find any match,
 	 * Which basically means
@@ -376,6 +420,9 @@
 	 */
 	V_rtstat.rts_unreach++;
 miss:
+#ifdef DEBUG
+	printf("rtalloc1_fib: miss\n");
+#endif
 	if (report) {
 		/*
 		 * If required, report the failure to the supervising
@@ -387,6 +434,9 @@
 		rt_missmsg(msgtype, &info, 0, err);
 	}	
 done:
+#ifdef DEBUG
+	printf("rtalloc1_fib: done\n");
+#endif
 	if (newrt)
 		RT_LOCK_ASSERT(newrt);
 	return (newrt);
@@ -396,10 +446,13 @@
  * Remove a reference count from an rtentry.
  * If the count gets low enough, take it out of the routing table
  */
-void
+	void
 rtfree(struct rtentry *rt)
 {
-	struct radix_node_head *rnh;
+#ifdef DEBUG
+	printf("rtfree\n");
+#endif
+	struct ptree *rnh;
 
 	KASSERT(rt != NULL,("%s: NULL rt", __func__));
 	rnh = rt_tables_get_rnh(rt->rt_fibnum, rt_key(rt)->sa_family);
@@ -427,7 +480,7 @@
 	 * on the entry so that the code below reclaims the storage.
 	 */
 	if (rt->rt_refcnt == 0 && rnh->rnh_close)
-		rnh->rnh_close((struct radix_node *)rt, rnh);
+		rnh->rnh_close((struct ptree_node *)rt, rnh);
 
 	/*
 	 * If we are no longer "up" (and ref == 0)
@@ -479,30 +532,36 @@
  * Normally called as a result of a routing redirect
  * message from the network layer.
  */
-void
+	void
 rtredirect(struct sockaddr *dst,
-	struct sockaddr *gateway,
-	struct sockaddr *netmask,
-	int flags,
-	struct sockaddr *src)
+		struct sockaddr *gateway,
+		struct sockaddr *netmask,
+		int flags,
+		struct sockaddr *src)
 {
+#ifdef DEBUG
+	printf("rtredirect\n");
+#endif
 	rtredirect_fib(dst, gateway, netmask, flags, src, 0);
 }
 
-void
+	void
 rtredirect_fib(struct sockaddr *dst,
-	struct sockaddr *gateway,
-	struct sockaddr *netmask,
-	int flags,
-	struct sockaddr *src,
-	u_int fibnum)
+		struct sockaddr *gateway,
+		struct sockaddr *netmask,
+		int flags,
+		struct sockaddr *src,
+		u_int fibnum)
 {
+#ifdef DEBUG
+	printf("rtredirect_fib\n");
+#endif
 	struct rtentry *rt, *rt0 = NULL;
 	int error = 0;
 	short *stat = NULL;
 	struct rt_addrinfo info;
 	struct ifaddr *ifa;
-	struct radix_node_head *rnh;
+	struct ptree *rnh;
 
 	ifa = NULL;
 	rnh = rt_tables_get_rnh(fibnum, dst->sa_family);
@@ -524,7 +583,7 @@
 	 * going down recently.
 	 */
 	if (!(flags & RTF_DONE) && rt &&
-	     (!sa_equal(src, rt->rt_gateway) || rt->rt_ifa != ifa))
+			(!sa_equal(src, rt->rt_gateway) || rt->rt_ifa != ifa))
 		error = EINVAL;
 	else if (ifa_ifwithaddr_check(gateway))
 		error = EHOSTUNREACH;
@@ -548,10 +607,10 @@
 			 * Changing from route to net => route to host.
 			 * Create new route, rather than smashing route to net.
 			 */
-		create:
+create:
 			rt0 = rt;
 			rt = NULL;
-		
+
 			flags |=  RTF_GATEWAY | RTF_DYNAMIC;
 			bzero((caddr_t)&info, sizeof(info));
 			info.rti_info[RTAX_DST] = dst;
@@ -570,7 +629,7 @@
 			}
 			if (rt0 != NULL)
 				RTFREE(rt0);
-			
+
 			stat = &V_rtstat.rts_dynamic;
 		} else {
 			struct rtentry *gwrt;
@@ -614,18 +673,24 @@
 		ifa_free(ifa);
 }
 
-int
+	int
 rtioctl(u_long req, caddr_t data)
 {
+#ifdef DEBUG
+	printf("rtioctl\n");
+#endif
 	return (rtioctl_fib(req, data, 0));
 }
 
 /*
  * Routing table ioctl interface.
  */
-int
+	int
 rtioctl_fib(u_long req, caddr_t data, u_int fibnum)
 {
+#ifdef DEBUG
+	printf("rtioctl_fib\n");
+#endif
 
 	/*
 	 * If more ioctl commands are added here, make sure the proper
@@ -644,16 +709,22 @@
 /*
  * For both ifa_ifwithroute() routines, 'ifa' is returned referenced.
  */
-struct ifaddr *
+	struct ifaddr *
 ifa_ifwithroute(int flags, struct sockaddr *dst, struct sockaddr *gateway)
 {
+#ifdef DEBUG
+	printf("ifa_ifwithroute\n");
+#endif
 	return (ifa_ifwithroute_fib(flags, dst, gateway, 0));
 }
 
-struct ifaddr *
+	struct ifaddr *
 ifa_ifwithroute_fib(int flags, struct sockaddr *dst, struct sockaddr *gateway,
-				u_int fibnum)
+		u_int fibnum)
 {
+#ifdef DEBUG
+	printf("ifa_ifwithroute_fib\n");
+#endif
 	register struct ifaddr *ifa;
 	int not_found = 0;
 
@@ -689,16 +760,16 @@
 		 * through the default router
 		 */
 		switch (gateway->sa_family) {
-		case AF_INET:
-			if (satosin(rt_key(rt))->sin_addr.s_addr == INADDR_ANY)
-				not_found = 1;
-			break;
-		case AF_INET6:
-			if (IN6_IS_ADDR_UNSPECIFIED(&satosin6(rt_key(rt))->sin6_addr))
-				not_found = 1;
-			break;
-		default:
-			break;
+			case AF_INET:
+				if (satosin(rt_key(rt))->sin_addr.s_addr == INADDR_ANY)
+					not_found = 1;
+				break;
+			case AF_INET6:
+				if (IN6_IS_ADDR_UNSPECIFIED(&satosin6(rt_key(rt))->sin6_addr))
+					not_found = 1;
+				break;
+			default:
+				break;
 		}
 		if (!not_found && rt->rt_ifa != NULL) {
 			ifa = rt->rt_ifa;
@@ -724,26 +795,32 @@
  * Do appropriate manipulations of a routing tree given
  * all the bits of info needed
  */
-int
+	int
 rtrequest(int req,
-	struct sockaddr *dst,
-	struct sockaddr *gateway,
-	struct sockaddr *netmask,
-	int flags,
-	struct rtentry **ret_nrt)
+		struct sockaddr *dst,
+		struct sockaddr *gateway,
+		struct sockaddr *netmask,
+		int flags,
+		struct rtentry **ret_nrt)
 {
+#ifdef DEBUG
+	printf("rtrequest\n");
+#endif
 	return (rtrequest_fib(req, dst, gateway, netmask, flags, ret_nrt, 0));
 }
 
-int
+	int
 rtrequest_fib(int req,
-	struct sockaddr *dst,
-	struct sockaddr *gateway,
-	struct sockaddr *netmask,
-	int flags,
-	struct rtentry **ret_nrt,
-	u_int fibnum)
+		struct sockaddr *dst,
+		struct sockaddr *gateway,
+		struct sockaddr *netmask,
+		int flags,
+		struct rtentry **ret_nrt,
+		u_int fibnum)
 {
+#ifdef DEBUG
+	printf("rtrequest_fib\n");
+#endif
 	struct rt_addrinfo info;
 
 	if (dst->sa_len == 0)
@@ -768,9 +845,12 @@
 #define	ifpaddr	info->rti_info[RTAX_IFP]
 #define	flags	info->rti_flags
 
-int
+	int
 rt_getifa(struct rt_addrinfo *info)
 {
+#ifdef DEBUG
+	printf("rt_getifa\n");
+#endif
 	return (rt_getifa_fib(info, 0));
 }
 
@@ -778,9 +858,12 @@
  * Look up rt_addrinfo for a specific fib.  Note that if rti_ifa is defined,
  * it will be referenced so the caller must free it.
  */
-int
+	int
 rt_getifa_fib(struct rt_addrinfo *info, u_int fibnum)
 {
+#ifdef DEBUG
+	printf("rt_getifa_fib\n");
+#endif
 	struct ifaddr *ifa;
 	int error = 0;
 
@@ -789,8 +872,8 @@
 	 * when protocol address is ambiguous.
 	 */
 	if (info->rti_ifp == NULL && ifpaddr != NULL &&
-	    ifpaddr->sa_family == AF_LINK &&
-	    (ifa = ifa_ifwithnet(ifpaddr)) != NULL) {
+			ifpaddr->sa_family == AF_LINK &&
+			(ifa = ifa_ifwithnet(ifpaddr)) != NULL) {
 		info->rti_ifp = ifa->ifa_ifp;
 		ifa_free(ifa);
 	}
@@ -800,15 +883,15 @@
 		struct sockaddr *sa;
 
 		sa = ifaaddr != NULL ? ifaaddr :
-		    (gateway != NULL ? gateway : dst);
+			(gateway != NULL ? gateway : dst);
 		if (sa != NULL && info->rti_ifp != NULL)
 			info->rti_ifa = ifaof_ifpforaddr(sa, info->rti_ifp);
 		else if (dst != NULL && gateway != NULL)
 			info->rti_ifa = ifa_ifwithroute_fib(flags, dst, gateway,
-							fibnum);
+					fibnum);
 		else if (sa != NULL)
 			info->rti_ifa = ifa_ifwithroute_fib(flags, sa, sa,
-							fibnum);
+					fibnum);
 	}
 	if ((ifa = info->rti_ifa) != NULL) {
 		if (info->rti_ifp == NULL)
@@ -822,11 +905,14 @@
  * Expunges references to a route that's about to be reclaimed.
  * The route must be locked.
  */
-int
+	int
 rtexpunge(struct rtentry *rt)
 {
-	struct radix_node *rn;
-	struct radix_node_head *rnh;
+#ifdef DEBUG
+	printf("rtexpunge\n");
+#endif
+	struct ptree_node *rn;
+	struct ptree *rnh;
 	struct ifaddr *ifa;
 	int error = 0;
 
@@ -856,9 +942,9 @@
 		goto bad;
 	}
 	KASSERT((rn->rn_flags & (RNF_ACTIVE | RNF_ROOT)) == 0,
-		("unexpected flags 0x%x", rn->rn_flags));
+			("unexpected flags 0x%x", rn->rn_flags));
 	KASSERT(rt == RNTORT(rn),
-		("lookup mismatch, rt %p rn %p", rt, rn));
+			("lookup mismatch, rt %p rn %p", rt, rn));
 
 	rt->rt_flags &= ~RTF_UP;
 
@@ -886,16 +972,16 @@
 }
 
 #ifdef RADIX_MPATH
-static int
+	static int
 rn_mpath_update(int req, struct rt_addrinfo *info,
-    struct radix_node_head *rnh, struct rtentry **ret_nrt)
+		struct ptree *rnh, struct rtentry **ret_nrt)
 {
 	/*
 	 * if we got multipath routes, we require users to specify
 	 * a matching RTAX_GATEWAY.
 	 */
 	struct rtentry *rt, *rto = NULL;
-	register struct radix_node *rn;
+	register struct ptree_node *rn;
 	int error = 0;
 
 	rn = rnh->rnh_matchaddr(dst, rnh);
@@ -909,7 +995,7 @@
 	 * this is the first entry in the chain
 	 */
 	if (rto == rt) {
-		rn = rn_mpath_next((struct radix_node *)rt);
+		rn = rn_mpath_next((struct ptree_node *)rt);
 		/*
 		 * there is another entry, now it's active
 		 */
@@ -928,8 +1014,8 @@
 			 * one route in the chain.  
 			 */
 			if (gateway &&
-			    (rt->rt_gateway->sa_len != gateway->sa_len ||
-				memcmp(rt->rt_gateway, gateway, gateway->sa_len)))
+					(rt->rt_gateway->sa_len != gateway->sa_len ||
+					 memcmp(rt->rt_gateway, gateway, gateway->sa_len)))
 				error = ESRCH;
 			else {
 				/*
@@ -940,7 +1026,7 @@
 				KASSERT(rt == RNTORT(rn), ("radix node disappeared"));
 				goto gwdelete;
 			}
-			
+
 		}
 		/*
 		 * use the normal delete code to remove
@@ -952,7 +1038,7 @@
 		error = ENOENT;
 		goto done;
 	}
-		
+
 	/*
 	 * if the entry is 2nd and on up
 	 */
@@ -970,11 +1056,11 @@
 		 */
 		V_rttrash++;
 	}
-	
+
 nondelete:
 	if (req != RTM_DELETE)
 		panic("unrecognized request %d", req);
-	
+
 
 	/*
 	 * If the caller wants it, then it can have it,
@@ -991,17 +1077,20 @@
 }
 #endif
 
-int
+	int
 rtrequest1_fib(int req, struct rt_addrinfo *info, struct rtentry **ret_nrt,
-				u_int fibnum)
+		u_int fibnum)
 {
+#ifdef DEBUG
+	printf("rtrequest1_fib\n");
+#endif
 	int error = 0, needlock = 0;
 	register struct rtentry *rt;
 #ifdef FLOWTABLE
 	register struct rtentry *rt0;
 #endif
-	register struct radix_node *rn;
-	register struct radix_node_head *rnh;
+	register struct ptree_node *rn;
+	register struct ptree *rnh;
 	struct ifaddr *ifa;
 	struct sockaddr *ndst;
 #define senderr(x) { error = x ; goto bad; }
@@ -1029,229 +1118,250 @@
 		netmask = NULL;
 
 	switch (req) {
-	case RTM_DELETE:
+		case RTM_DELETE:
+#ifdef DEBUG
+			printf("case RTM_DELETE:\n");
+#endif
 #ifdef RADIX_MPATH
-		if (rn_mpath_capable(rnh)) {
-			error = rn_mpath_update(req, info, rnh, ret_nrt);
+			if (rn_mpath_capable(rnh)) {
+				error = rn_mpath_update(req, info, rnh, ret_nrt);
+				/*
+				 * "bad" holds true for the success case
+				 * as well
+				 */
+				if (error != ENOENT)
+					goto bad;
+			}
+#endif
 			/*
-			 * "bad" holds true for the success case
-			 * as well
+			 * Remove the item from the tree and return it.
+			 * Complain if it is not there and do no more processing.
 			 */
-			if (error != ENOENT)
-				goto bad;
-		}
-#endif
-		/*
-		 * Remove the item from the tree and return it.
-		 * Complain if it is not there and do no more processing.
-		 */
-		rn = rnh->rnh_deladdr(dst, netmask, rnh);
-		if (rn == NULL)
-			senderr(ESRCH);
-		if (rn->rn_flags & (RNF_ACTIVE | RNF_ROOT))
-			panic ("rtrequest delete");
-		rt = RNTORT(rn);
-		RT_LOCK(rt);
-		RT_ADDREF(rt);
-		rt->rt_flags &= ~RTF_UP;
+			rn = rnh->rnh_deladdr(dst, netmask, rnh);
+			if (rn == NULL)
+				senderr(ESRCH);
+			if (rn->rn_flags & (RNF_ACTIVE | RNF_ROOT))
+				panic ("rtrequest delete");
+			rt = RNTORT(rn);
+			RT_LOCK(rt);
+			RT_ADDREF(rt);
+			rt->rt_flags &= ~RTF_UP;
 
-		/*
-		 * give the protocol a chance to keep things in sync.
-		 */
-		if ((ifa = rt->rt_ifa) && ifa->ifa_rtrequest)
-			ifa->ifa_rtrequest(RTM_DELETE, rt, info);
+			/*
+			 * give the protocol a chance to keep things in sync.
+			 */
+			if ((ifa = rt->rt_ifa) && ifa->ifa_rtrequest)
+				ifa->ifa_rtrequest(RTM_DELETE, rt, info);
 
-		/*
-		 * One more rtentry floating around that is not
-		 * linked to the routing table. rttrash will be decremented
-		 * when RTFREE(rt) is eventually called.
-		 */
-		V_rttrash++;
+			/*
+			 * One more rtentry floating around that is not
+			 * linked to the routing table. rttrash will be decremented
+			 * when RTFREE(rt) is eventually called.
+			 */
+			V_rttrash++;
 
-		/*
-		 * If the caller wants it, then it can have it,
-		 * but it's up to it to free the rtentry as we won't be
-		 * doing it.
-		 */
-		if (ret_nrt) {
-			*ret_nrt = rt;
-			RT_UNLOCK(rt);
-		} else
-			RTFREE_LOCKED(rt);
-		break;
-	case RTM_RESOLVE:
-		/*
-		 * resolve was only used for route cloning
-		 * here for compat
-		 */
-		break;
-	case RTM_ADD:
-		if ((flags & RTF_GATEWAY) && !gateway)
-			senderr(EINVAL);
-		if (dst && gateway && (dst->sa_family != gateway->sa_family) && 
-		    (gateway->sa_family != AF_UNSPEC) && (gateway->sa_family != AF_LINK))
-			senderr(EINVAL);
-
-		if (info->rti_ifa == NULL) {
-			error = rt_getifa_fib(info, fibnum);
-			if (error)
+			/*
+			 * If the caller wants it, then it can have it,
+			 * but it's up to it to free the rtentry as we won't be
+			 * doing it.
+			 */
+			if (ret_nrt) {
+				*ret_nrt = rt;
+				RT_UNLOCK(rt);
+			} else
+				RTFREE_LOCKED(rt);
+			break;
+		case RTM_RESOLVE:
+			/*
+			 * resolve was only used for route cloning
+			 * here for compat
+			 */
+			break;
+		case RTM_ADD:
+#ifdef DEBUG
+			printf("case RTM_ADD:\n");
+#endif
+			if ((flags & RTF_GATEWAY) && !gateway)
+				senderr(EINVAL);
+			if (dst && gateway && (dst->sa_family != gateway->sa_family) && 
+					(gateway->sa_family != AF_UNSPEC) && (gateway->sa_family != AF_LINK))
+				senderr(EINVAL);
+
+			if (info->rti_ifa == NULL) {
+				error = rt_getifa_fib(info, fibnum);
+				if (error)
+					senderr(error);
+			} else
+				ifa_ref(info->rti_ifa);
+			ifa = info->rti_ifa;
+			rt = uma_zalloc(V_rtzone, M_NOWAIT | M_ZERO);
+			if (rt == NULL) {
+				if (ifa != NULL)
+					ifa_free(ifa);
+				senderr(ENOBUFS);
+			}
+			RT_LOCK_INIT(rt);
+			rt->rt_flags = RTF_UP | flags;
+			rt->rt_fibnum = fibnum;
+			/*
+			 * Add the gateway. Possibly re-malloc-ing the storage for it
+			 * 
+			 */
+			RT_LOCK(rt);
+			if ((error = rt_setgate(rt, dst, gateway)) != 0) {
+				RT_LOCK_DESTROY(rt);
+				if (ifa != NULL)
+					ifa_free(ifa);
+				uma_zfree(V_rtzone, rt);
 				senderr(error);
-		} else
-			ifa_ref(info->rti_ifa);
-		ifa = info->rti_ifa;
-		rt = uma_zalloc(V_rtzone, M_NOWAIT | M_ZERO);
-		if (rt == NULL) {
-			if (ifa != NULL)
-				ifa_free(ifa);
-			senderr(ENOBUFS);
-		}
-		RT_LOCK_INIT(rt);
-		rt->rt_flags = RTF_UP | flags;
-		rt->rt_fibnum = fibnum;
-		/*
-		 * Add the gateway. Possibly re-malloc-ing the storage for it
-		 * 
-		 */
-		RT_LOCK(rt);
-		if ((error = rt_setgate(rt, dst, gateway)) != 0) {
-			RT_LOCK_DESTROY(rt);
-			if (ifa != NULL)
-				ifa_free(ifa);
-			uma_zfree(V_rtzone, rt);
-			senderr(error);
-		}
+			}
 
-		/*
-		 * point to the (possibly newly malloc'd) dest address.
-		 */
-		ndst = (struct sockaddr *)rt_key(rt);
+			/*
+			 * point to the (possibly newly malloc'd) dest address.
+			 */
+			ndst = (struct sockaddr *)rt_key(rt);
 
-		/*
-		 * make sure it contains the value we want (masked if needed).
-		 */
-		if (netmask) {
-			rt_maskedcopy(dst, ndst, netmask);
-		} else
-			bcopy(dst, ndst, dst->sa_len);
+			/*
+			 * make sure it contains the value we want (masked if needed).
+			 */
+			if (netmask) {
+				rt_maskedcopy(dst, ndst, netmask);
+			} else
+				bcopy(dst, ndst, dst->sa_len);
 
-		/*
-		 * We use the ifa reference returned by rt_getifa_fib().
-		 * This moved from below so that rnh->rnh_addaddr() can
-		 * examine the ifa and  ifa->ifa_ifp if it so desires.
-		 */
-		rt->rt_ifa = ifa;
-		rt->rt_ifp = ifa->ifa_ifp;
-		rt->rt_rmx.rmx_weight = 1;
+			/*
+			 * We use the ifa reference returned by rt_getifa_fib().
+			 * This moved from below so that rnh->rnh_addaddr() can
+			 * examine the ifa and  ifa->ifa_ifp if it so desires.
+			 */
+			rt->rt_ifa = ifa;
+			rt->rt_ifp = ifa->ifa_ifp;
+			rt->rt_rmx.rmx_weight = 1;
 
 #ifdef RADIX_MPATH
-		/* do not permit exactly the same dst/mask/gw pair */
-		if (rn_mpath_capable(rnh) &&
-			rt_mpath_conflict(rnh, rt, netmask)) {
-			if (rt->rt_ifa) {
-				ifa_free(rt->rt_ifa);
+			/* do not permit exactly the same dst/mask/gw pair */
+			if (rn_mpath_capable(rnh) &&
+					rt_mpath_conflict(rnh, rt, netmask)) {
+				if (rt->rt_ifa) {
+					ifa_free(rt->rt_ifa);
+				}
+				Free(rt_key(rt));
+				RT_LOCK_DESTROY(rt);
+				uma_zfree(V_rtzone, rt);
+				senderr(EEXIST);
 			}
-			Free(rt_key(rt));
-			RT_LOCK_DESTROY(rt);
-			uma_zfree(V_rtzone, rt);
-			senderr(EEXIST);
-		}
 #endif
 
 #ifdef FLOWTABLE
-		rt0 = NULL;
-		/* XXX
-		 * "flow-table" only support IPv4 at the moment.
-		 */
+			rt0 = NULL;
+			/* XXX
+			 * "flow-table" only support IPv4 at the moment.
+			 */
 #ifdef INET
-		if (dst->sa_family == AF_INET) {
-			rn = rnh->rnh_matchaddr(dst, rnh);
-			if (rn && ((rn->rn_flags & RNF_ROOT) == 0)) {
-				struct sockaddr *mask;
-				u_char *m, *n;
-				int len;
-				
-				/*
-				 * compare mask to see if the new route is
-				 * more specific than the existing one
-				 */
-				rt0 = RNTORT(rn);
-				RT_LOCK(rt0);
-				RT_ADDREF(rt0);
-				RT_UNLOCK(rt0);
-				/*
-				 * A host route is already present, so 
-				 * leave the flow-table entries as is.
-				 */
-				if (rt0->rt_flags & RTF_HOST) {
-					RTFREE(rt0);
-					rt0 = NULL;
-				} else if (!(flags & RTF_HOST) && netmask) {
-					mask = rt_mask(rt0);
-					len = mask->sa_len;
-					m = (u_char *)mask;
-					n = (u_char *)netmask;
-					while (len-- > 0) {
-						if (*n != *m)
-							break;
-						n++;
-						m++;
-					}
-					if (len == 0 || (*n < *m)) {
+			if (dst->sa_family == AF_INET) {
+				rn = rnh->rnh_matchaddr(dst, rnh);
+#ifdef DEBUG
+				printf("rtreq_ADD: match node = %p\n",rn);
+#endif
+				if (rn && ((rn->rn_flags & RNF_ROOT) == 0)) {
+					struct sockaddr *mask;
+					u_char *m, *n;
+					int len;
+
+					/*
+					 * compare mask to see if the new route is
+					 * more specific than the existing one
+					 */
+					rt0 = RNTORT(rn);
+					RT_LOCK(rt0);
+					RT_ADDREF(rt0);
+					RT_UNLOCK(rt0);
+#ifdef DEBUG
+					printf("rtreq_ADD: compared mask\n");
+#endif
+					/*
+					 * A host route is already present, so 
+					 * leave the flow-table entries as is.
+					 */
+					if (rt0->rt_flags & RTF_HOST) {
+#ifdef DEBUG
+					printf("rtreq_ADD: flags & RTF_HOST\n");
+#endif
 						RTFREE(rt0);
 						rt0 = NULL;
+					} else if (!(flags & RTF_HOST) && netmask) {
+#ifdef DEBUG
+						printf("rtreq_ADD: !flags & RTF_HOST\n");
+#endif
+						mask = rt_mask(rt0);
+						len = mask->sa_len;
+						m = (u_char *)mask;
+						n = (u_char *)netmask;
+						while (len-- > 0) {
+							if (*n != *m)
+								break;
+							n++;
+							m++;
+						}
+						if (len == 0 || (*n < *m)) {
+#ifdef DEBUG
+							printf("rtreq_ADD: len = 0\n");
+#endif
+							RTFREE(rt0);
+							rt0 = NULL;
+						}
 					}
 				}
 			}
-		}
 #endif
 #endif
 
-		/* XXX mtu manipulation will be done in rnh_addaddr -- itojun */
-		rn = rnh->rnh_addaddr(ndst, netmask, rnh, rt->rt_nodes);
-		/*
-		 * If it still failed to go into the tree,
-		 * then un-make it (this should be a function)
-		 */
-		if (rn == NULL) {
-			if (rt->rt_ifa)
-				ifa_free(rt->rt_ifa);
-			Free(rt_key(rt));
-			RT_LOCK_DESTROY(rt);
-			uma_zfree(V_rtzone, rt);
+			/* XXX mtu manipulation will be done in rnh_addaddr -- itojun */
+			rn = rnh->rnh_addaddr(ndst, netmask, rnh, rt->rt_nodes);
+			/*
+			 * If it still failed to go into the tree,
+			 * then un-make it (this should be a function)
+			 */
+			if (rn == NULL) {
+				if (rt->rt_ifa)
+					ifa_free(rt->rt_ifa);
+				Free(rt_key(rt));
+				RT_LOCK_DESTROY(rt);
+				uma_zfree(V_rtzone, rt);
 #ifdef FLOWTABLE
-			if (rt0 != NULL)
-				RTFREE(rt0);
+				if (rt0 != NULL)
+					RTFREE(rt0);
 #endif
-			senderr(EEXIST);
-		} 
+				senderr(EEXIST);
+			} 
 #ifdef FLOWTABLE
-		else if (rt0 != NULL) {
+			else if (rt0 != NULL) {
 #ifdef INET
-			flowtable_route_flush(V_ip_ft, rt0);
+				flowtable_route_flush(V_ip_ft, rt0);
 #endif
-			RTFREE(rt0);
-		}
+				RTFREE(rt0);
+			}
 #endif
 
-		/*
-		 * If this protocol has something to add to this then
-		 * allow it to do that as well.
-		 */
-		if (ifa->ifa_rtrequest)
-			ifa->ifa_rtrequest(req, rt, info);
+			/*
+			 * If this protocol has something to add to this then
+			 * allow it to do that as well.
+			 */
+			if (ifa->ifa_rtrequest)
+				ifa->ifa_rtrequest(req, rt, info);
 
-		/*
-		 * actually return a resultant rtentry and
-		 * give the caller a single reference.
-		 */
-		if (ret_nrt) {
-			*ret_nrt = rt;
-			RT_ADDREF(rt);
-		}
-		RT_UNLOCK(rt);
-		break;
-	default:
-		error = EOPNOTSUPP;
+			/*
+			 * actually return a resultant rtentry and
+			 * give the caller a single reference.
+			 */
+			if (ret_nrt) {
+				*ret_nrt = rt;
+				RT_ADDREF(rt);
+			}
+			RT_UNLOCK(rt);
+			break;
+		default:
+			error = EOPNOTSUPP;
 	}
 bad:
 	if (needlock)
@@ -1267,20 +1377,23 @@
 #undef ifpaddr
 #undef flags
 
-int
+	int
 rt_setgate(struct rtentry *rt, struct sockaddr *dst, struct sockaddr *gate)
 {
+#ifdef DEBUG
+	printf("rt_setgate\n");
+#endif
 	/* XXX dst may be overwritten, can we move this to below */
 	int dlen = SA_SIZE(dst), glen = SA_SIZE(gate);
 #ifdef INVARIANTS
-	struct radix_node_head *rnh;
+	struct ptree *rnh;
 
 	rnh = rt_tables_get_rnh(rt->rt_fibnum, dst->sa_family);
 #endif
 
 	RT_LOCK_ASSERT(rt);
 	RADIX_NODE_HEAD_LOCK_ASSERT(rnh);
-	
+
 	/*
 	 * Prepare to store the gateway in rt->rt_gateway.
 	 * Both dst and gateway are stored one after the other in the same
@@ -1315,9 +1428,12 @@
 	return (0);
 }
 
-static void
+	static void
 rt_maskedcopy(struct sockaddr *src, struct sockaddr *dst, struct sockaddr *netmask)
 {
+#ifdef DEBUG
+	printf("rt_maskedcopy\n");
+#endif
 	register u_char *cp1 = (u_char *)src;
 	register u_char *cp2 = (u_char *)dst;
 	register u_char *cp3 = (u_char *)netmask;
@@ -1339,9 +1455,12 @@
  * for an interface.
  */
 #define _SOCKADDR_TMPSIZE 128 /* Not too big.. kernel stack size is limited */
-static inline  int
+	static inline  int
 rtinit1(struct ifaddr *ifa, int cmd, int flags, int fibnum)
 {
+#ifdef DEBUG
+	printf("rtinit1\n");
+#endif
 	struct sockaddr *dst;
 	struct sockaddr *netmask;
 	struct rtentry *rt = NULL;
@@ -1405,8 +1524,8 @@
 	 */
 	for ( fibnum = startfib; fibnum <= endfib; fibnum++) {
 		if (cmd == RTM_DELETE) {
-			struct radix_node_head *rnh;
-			struct radix_node *rn;
+			struct ptree *rnh;
+			struct ptree_node *rn;
 			/*
 			 * Look up an rtentry that is in the routing tree and
 			 * contains the correct info.
@@ -1432,18 +1551,18 @@
 					 * interface address
 					 */
 					rt = rt_mpath_matchgate(rt,
-					    ifa->ifa_addr);
+							ifa->ifa_addr);
 					if (!rt) 
 						error = ESRCH;
 				}
 			}
 			else
 #endif
-			rn = rnh->rnh_lookup(dst, netmask, rnh);
+				rn = rnh->rnh_lookup(dst, netmask,(int)dst, rnh);
 			error = (rn == NULL ||
-			    (rn->rn_flags & RNF_ROOT) ||
-			    RNTORT(rn)->rt_ifa != ifa ||
-			    !sa_equal((struct sockaddr *)rn->rn_key, dst));
+					(rn->rn_flags & RNF_ROOT) ||
+					RNTORT(rn)->rt_ifa != ifa ||
+					!sa_equal((struct sockaddr *)rn->rn_key, dst));
 			RADIX_NODE_HEAD_UNLOCK(rnh);
 			if (error) {
 				/* this is only an error if bad on ALL tables */
@@ -1462,7 +1581,7 @@
 		 */
 		if (cmd == RTM_ADD)
 			info.rti_info[RTAX_GATEWAY] =
-			    (struct sockaddr *)&null_sdl;
+				(struct sockaddr *)&null_sdl;
 		else
 			info.rti_info[RTAX_GATEWAY] = ifa->ifa_addr;
 		info.rti_info[RTAX_NETMASK] = netmask;
@@ -1481,7 +1600,7 @@
 			 * so we need to replace it with 192.103.54.247
 			 */
 			if (memcmp(rt->rt_ifa->ifa_addr,
-			    ifa->ifa_addr, ifa->ifa_addr->sa_len)) {
+						ifa->ifa_addr, ifa->ifa_addr->sa_len)) {
 				ifa_free(rt->rt_ifa);
 				ifa_ref(ifa);
 				rt->rt_ifp = ifa->ifa_ifp;
@@ -1492,10 +1611,10 @@
 			 * doing this for compatibility reasons
 			 */
 			if (cmd == RTM_ADD) {
-			    ((struct sockaddr_dl *)rt->rt_gateway)->sdl_type  =
-				rt->rt_ifp->if_type;
-			    ((struct sockaddr_dl *)rt->rt_gateway)->sdl_index =
-				rt->rt_ifp->if_index;
+				((struct sockaddr_dl *)rt->rt_gateway)->sdl_type  =
+					rt->rt_ifp->if_type;
+				((struct sockaddr_dl *)rt->rt_gateway)->sdl_index =
+					rt->rt_ifp->if_index;
 			}
 			rt_newaddrmsg(cmd, ifa, error, rt);
 			if (cmd == RTM_DELETE) {
@@ -1526,7 +1645,7 @@
 		} else {
 			/* we only give an error if it wasn't in any table */
 			error = ((flags & RTF_HOST) ?
-			    EHOSTUNREACH : ENETUNREACH);
+					EHOSTUNREACH : ENETUNREACH);
 		}
 	} else {
 		if (a_failure) {
@@ -1538,9 +1657,12 @@
 }
 
 /* special one for inet internal use. may not use. */
-int
+	int
 rtinit_fib(struct ifaddr *ifa, int cmd, int flags)
 {
+#ifdef DEBUG
+	printf("rtinit1_fib\n");
+#endif
 	return (rtinit1(ifa, cmd, flags, -1));
 }
 
@@ -1548,9 +1670,12 @@
  * Set up a routing table entry, normally
  * for an interface.
  */
-int
+	int
 rtinit(struct ifaddr *ifa, int cmd, int flags)
 {
+#ifdef DEBUG
+	printf("rtinit\n");
+#endif
 	struct sockaddr *dst;
 	int fib = 0;
 
