--- route.c.orig	2005-02-24 13:50:32.000000000 +0900
+++ route.c	2010-12-17 19:21:12.000000000 +0900
@@ -38,6 +38,7 @@
 #include "opt_route.h"
 #include "opt_mrouting.h"
 #include "opt_mpath.h"
+#include "opt_ptree.h"
 
 #include <sys/param.h>
 #include <sys/systm.h>
@@ -58,15 +59,15 @@
 #include <net/vnet.h>
 #include <net/flowtable.h>
 
-#ifdef RADIX_MPATH
-#include <net/radix_mpath.h>
-#endif
-
 #include <netinet/in.h>
 #include <netinet/ip_mroute.h>
 
 #include <vm/uma.h>
 
+#ifdef DEBUG
+#include <netdb.h>
+#endif
+
 u_int rt_numfibs = RT_NUMFIBS;
 SYSCTL_INT(_net, OID_AUTO, fibs, CTLFLAG_RD, &rt_numfibs, 0, "");
 /*
@@ -85,10 +86,10 @@
  */
 u_int rt_add_addr_allfibs = 1;
 SYSCTL_INT(_net, OID_AUTO, add_addr_allfibs, CTLFLAG_RW,
-    &rt_add_addr_allfibs, 0, "");
+				&rt_add_addr_allfibs, 0, "");
 TUNABLE_INT("net.add_addr_allfibs", &rt_add_addr_allfibs);
 
-VNET_DEFINE(struct radix_node_head *, rt_tables);
+VNET_DEFINE(struct ptree_node_head *, rt_tables);
 static VNET_DEFINE(uma_zone_t, rtzone);		/* Routing table UMA zone. */
 VNET_DEFINE(int, rttrash);		/* routes not in table but not freed */
 VNET_DEFINE(struct rtstat, rtstat);
@@ -99,7 +100,7 @@
 #define	V_rtstat	VNET(rtstat)
 
 static void rt_maskedcopy(struct sockaddr *,
-	    struct sockaddr *, struct sockaddr *);
+				struct sockaddr *, struct sockaddr *);
 
 /* compare two sockaddr structures */
 #define	sa_equal(a1, a2) (bcmp((a1), (a2), (a1)->sa_len) == 0)
@@ -114,7 +115,7 @@
  * But because there are a lot of assumptions in this conversion,
  * do not cast explicitly, but always use the macro below.
  */
-#define RNTORT(p)	((struct rtentry *)(p))
+#define RNTORT(p)	((struct rtentry *)(p->data))
 
 #if 0
 /* default fib for tunnels to use */
@@ -125,42 +126,40 @@
 /*
  * handler for net.my_fibnum
  */
-static int
+		static int
 sysctl_my_fibnum(SYSCTL_HANDLER_ARGS)
 {
-        int fibnum;
-        int error;
- 
-        fibnum = curthread->td_proc->p_fibnum;
-        error = sysctl_handle_int(oidp, &fibnum, 0, req);
-        return (error);
+	int fibnum;
+	int error;
+
+	fibnum = curthread->td_proc->p_fibnum;
+	error = sysctl_handle_int(oidp, &fibnum, 0, req);
+	return (error);
 }
 
 SYSCTL_PROC(_net, OID_AUTO, my_fibnum, CTLTYPE_INT|CTLFLAG_RD,
-            NULL, 0, &sysctl_my_fibnum, "I", "default FIB of caller");
+				NULL, 0, &sysctl_my_fibnum, "I", "default FIB of caller");
 
-static __inline struct radix_node_head **
+		static __inline struct ptree_node_head **
 rt_tables_get_rnh_ptr(int table, int fam)
 {
-	struct radix_node_head **rnh;
+	struct ptree_node_head **rnh;
 
-	KASSERT(table >= 0 && table < rt_numfibs, ("%s: table out of bounds.",
-	    __func__));
+	KASSERT(table >= 0 && table < rt_numfibs, ("%s: table out of bounds.", __func__));
 	KASSERT(fam >= 0 && fam < (AF_MAX+1), ("%s: fam out of bounds.",
-	    __func__));
+								__func__));
 
 	/* rnh is [fib=0][af=0]. */
-	rnh = (struct radix_node_head **)V_rt_tables;
+	rnh = (struct ptree_node_head **)V_rt_tables;
 	/* Get the offset to the requested table and fam. */
 	rnh += table * (AF_MAX+1) + fam;
 
 	return (rnh);
 }
 
-struct radix_node_head *
+		struct ptree_node_head *
 rt_tables_get_rnh(int table, int fam)
 {
-
 	return (*rt_tables_get_rnh_ptr(table, fam));
 }
 
@@ -168,89 +167,88 @@
  * route initialization must occur before ip6_init2(), which happenas at
  * SI_ORDER_MIDDLE.
  */
-static void
+		static void
 route_init(void)
 {
-
 	/* whack the tunable ints into  line. */
 	if (rt_numfibs > RT_MAXFIBS)
-		rt_numfibs = RT_MAXFIBS;
+			rt_numfibs = RT_MAXFIBS;
 	if (rt_numfibs == 0)
-		rt_numfibs = 1;
-	rn_init();	/* initialize all zeroes, all ones, mask table */
+			rt_numfibs = 1;
+	ptree_init();
 }
 SYSINIT(route_init, SI_SUB_PROTO_DOMAIN, SI_ORDER_THIRD, route_init, 0);
 
-static void
+		static void
 vnet_route_init(const void *unused __unused)
 {
 	struct domain *dom;
-	struct radix_node_head **rnh;
+	struct ptree_node_head **rnh;
 	int table;
 	int fam;
 
 	V_rt_tables = malloc(rt_numfibs * (AF_MAX+1) *
-	    sizeof(struct radix_node_head *), M_RTABLE, M_WAITOK|M_ZERO);
+			sizeof(struct ptree_node_head *), M_RTABLE, M_WAITOK|M_ZERO);
 
 	V_rtzone = uma_zcreate("rtentry", sizeof(struct rtentry), NULL, NULL,
-	    NULL, NULL, UMA_ALIGN_PTR, 0);
+					NULL, NULL, UMA_ALIGN_PTR, 0);
 	for (dom = domains; dom; dom = dom->dom_next) {
-		if (dom->dom_rtattach)  {
-			for  (table = 0; table < rt_numfibs; table++) {
-				if ( (fam = dom->dom_family) == AF_INET ||
-				    table == 0) {
- 			        	/* for now only AF_INET has > 1 table */
-					/* XXX MRT 
-					 * rtattach will be also called
-					 * from vfs_export.c but the
-					 * offset will be 0
-					 * (only for AF_INET and AF_INET6
-					 * which don't need it anyhow)
-					 */
-					rnh = rt_tables_get_rnh_ptr(table, fam);
-					if (rnh == NULL)
-						panic("%s: rnh NULL", __func__);
-					dom->dom_rtattach((void **)rnh,
-				    	    dom->dom_rtoffset);
-				} else {
-					break;
-				}
+			if (dom->dom_rtattach)  {
+					for  (table = 0; table < rt_numfibs; table++) {
+							if ( (fam = dom->dom_family) == AF_INET 
+											|| table == 0) {
+									/* for now only AF_INET has > 1 table */
+									/* XXX MRT 
+									 * rtattach will be also called
+									 * from vfs_export.c but the
+									 * offset will be 0
+									 * (only for AF_INET and AF_INET6
+									 * which don't need it anyhow)
+									 */
+									rnh = rt_tables_get_rnh_ptr(table, fam);
+									if (rnh == NULL)
+											panic("%s: rnh NULL", __func__);
+									dom->dom_rtattach((void **)rnh,
+													dom->dom_rtoffset);
+							} else {
+									break;
+							}
+					}
 			}
-		}
 	}
 }
 VNET_SYSINIT(vnet_route_init, SI_SUB_PROTO_DOMAIN, SI_ORDER_FOURTH,
-    vnet_route_init, 0);
+				vnet_route_init, 0);
 
 #ifdef VIMAGE
-static void
+		static void
 vnet_route_uninit(const void *unused __unused)
 {
 	int table;
 	int fam;
 	struct domain *dom;
-	struct radix_node_head **rnh;
+	struct ptree_node_head **rnh;
 
 	for (dom = domains; dom; dom = dom->dom_next) {
-		if (dom->dom_rtdetach) {
-			for (table = 0; table < rt_numfibs; table++) {
-				if ( (fam = dom->dom_family) == AF_INET ||
-				    table == 0) {
-					/* For now only AF_INET has > 1 tbl. */
-					rnh = rt_tables_get_rnh_ptr(table, fam);
-					if (rnh == NULL)
-						panic("%s: rnh NULL", __func__);
-					dom->dom_rtdetach((void **)rnh,
-					    dom->dom_rtoffset);
-				} else {
-					break;
-				}
+			if (dom->dom_rtdetach) {
+					for (table = 0; table < rt_numfibs; table++) {
+							if ( (fam = dom->dom_family) == AF_INET ||
+											table == 0) {
+									/* For now only AF_INET has > 1 tbl. */
+									rnh = rt_tables_get_rnh_ptr(table, fam);
+									if (rnh == NULL)
+											panic("%s: rnh NULL", __func__);
+									dom->dom_rtdetach((void **)rnh,
+													dom->dom_rtoffset);
+							} else {
+									break;
+							}
+					}
 			}
-		}
 	}
 }
 VNET_SYSUNINIT(vnet_route_uninit, SI_SUB_PROTO_DOMAIN, SI_ORDER_THIRD,
-    vnet_route_uninit, 0);
+				vnet_route_uninit, 0);
 #endif
 
 #ifndef _SYS_SYSPROTO_H_
@@ -258,11 +256,11 @@
 	int     fibnum;
 };
 #endif
-int
+		int
 setfib(struct thread *td, struct setfib_args *uap)
 {
 	if (uap->fibnum < 0 || uap->fibnum >= rt_numfibs)
-		return EINVAL;
+			return EINVAL;
 	td->td_proc->p_fibnum = uap->fibnum;
 	return (0);
 }
@@ -270,48 +268,48 @@
 /*
  * Packet routing routines.
  */
-void
+		void
 rtalloc(struct route *ro)
 {
 	rtalloc_ign_fib(ro, 0UL, 0);
 }
 
-void
+		void
 rtalloc_fib(struct route *ro, u_int fibnum)
 {
 	rtalloc_ign_fib(ro, 0UL, fibnum);
 }
 
-void
+		void
 rtalloc_ign(struct route *ro, u_long ignore)
 {
 	struct rtentry *rt;
 
 	if ((rt = ro->ro_rt) != NULL) {
-		if (rt->rt_ifp != NULL && rt->rt_flags & RTF_UP)
-			return;
-		RTFREE(rt);
-		ro->ro_rt = NULL;
+			if (rt->rt_ifp != NULL && rt->rt_flags & RTF_UP)
+					return;
+			RTFREE(rt);
+			ro->ro_rt = NULL;
 	}
 	ro->ro_rt = rtalloc1_fib(&ro->ro_dst, 1, ignore, 0);
 	if (ro->ro_rt)
-		RT_UNLOCK(ro->ro_rt);
+			RT_UNLOCK(ro->ro_rt);
 }
 
-void
+		void
 rtalloc_ign_fib(struct route *ro, u_long ignore, u_int fibnum)
 {
 	struct rtentry *rt;
 
 	if ((rt = ro->ro_rt) != NULL) {
-		if (rt->rt_ifp != NULL && rt->rt_flags & RTF_UP)
-			return;
-		RTFREE(rt);
-		ro->ro_rt = NULL;
+			if (rt->rt_ifp != NULL && rt->rt_flags & RTF_UP)
+					return;
+			RTFREE(rt);
+			ro->ro_rt = NULL;
 	}
 	ro->ro_rt = rtalloc1_fib(&ro->ro_dst, 1, ignore, fibnum);
 	if (ro->ro_rt)
-		RT_UNLOCK(ro->ro_rt);
+			RT_UNLOCK(ro->ro_rt);
 }
 
 /*
@@ -320,55 +318,55 @@
  *
  * The returned route, if any, is locked.
  */
-struct rtentry *
+		struct rtentry *
 rtalloc1(struct sockaddr *dst, int report, u_long ignflags)
 {
 	return (rtalloc1_fib(dst, report, ignflags, 0));
 }
 
-struct rtentry *
+		struct rtentry *
 rtalloc1_fib(struct sockaddr *dst, int report, u_long ignflags,
-		    u_int fibnum)
+				u_int fibnum)
 {
-	struct radix_node_head *rnh;
+	struct ptree_node_head *rnh;
 	struct rtentry *rt;
-	struct radix_node *rn;
+	struct ptree_node *rn;
 	struct rtentry *newrt;
 	struct rt_addrinfo info;
 	int err = 0, msgtype = RTM_MISS;
 	int needlock;
+	dprint(("rtalloc1_fib Start\n"));
 
 	KASSERT((fibnum < rt_numfibs), ("rtalloc1_fib: bad fibnum"));
 	if (dst->sa_family != AF_INET)	/* Only INET supports > 1 fib now */
-		fibnum = 0;
+			fibnum = 0;
 	rnh = rt_tables_get_rnh(fibnum, dst->sa_family);
 	newrt = NULL;
 	/*
 	 * Look up the address in the table for that Address Family
 	 */
 	if (rnh == NULL) {
-		V_rtstat.rts_unreach++;
-		goto miss;
+			V_rtstat.rts_unreach++;
+			goto miss;
 	}
 	needlock = !(ignflags & RTF_RNH_LOCKED);
 	if (needlock)
-		RADIX_NODE_HEAD_RLOCK(rnh);
+			RADIX_NODE_HEAD_RLOCK(rnh);
 #ifdef INVARIANTS	
 	else
-		RADIX_NODE_HEAD_LOCK_ASSERT(rnh);
+			RADIX_NODE_HEAD_LOCK_ASSERT(rnh);
 #endif
 	rn = rnh->rnh_matchaddr(dst, rnh);
-	if (rn && ((rn->rn_flags & RNF_ROOT) == 0)) {
-		newrt = rt = RNTORT(rn);
-		RT_LOCK(newrt);
-		RT_ADDREF(newrt);
-		if (needlock)
+	if (rn/* && ((rn->rn_flags & RNF_ROOT) == 0)*/) {
+			newrt = rt = RNTORT(rn);
+			RT_LOCK(newrt);
+			RT_ADDREF(newrt);
+			if (needlock)
+					RADIX_NODE_HEAD_RUNLOCK(rnh);
+			goto done;
+	} else if (needlock)
 			RADIX_NODE_HEAD_RUNLOCK(rnh);
-		goto done;
 
-	} else if (needlock)
-		RADIX_NODE_HEAD_RUNLOCK(rnh);
-	
 	/*
 	 * Either we hit the root or couldn't find any match,
 	 * Which basically means
@@ -377,18 +375,19 @@
 	V_rtstat.rts_unreach++;
 miss:
 	if (report) {
-		/*
-		 * If required, report the failure to the supervising
-		 * Authorities.
-		 * For a delete, this is not an error. (report == 0)
-		 */
-		bzero(&info, sizeof(info));
-		info.rti_info[RTAX_DST] = dst;
-		rt_missmsg(msgtype, &info, 0, err);
+			/*
+			 * If required, report the failure to the supervising
+			 * Authorities.
+			 * For a delete, this is not an error. (report == 0)
+			 */
+			bzero(&info, sizeof(info));
+			info.rti_info[RTAX_DST] = dst;
+			rt_missmsg(msgtype, &info, 0, err);
 	}	
 done:
 	if (newrt)
-		RT_LOCK_ASSERT(newrt);
+			RT_LOCK_ASSERT(newrt);
+	dprint(("rtalloc1_End\n"));
 	return (newrt);
 }
 
@@ -396,10 +395,11 @@
  * Remove a reference count from an rtentry.
  * If the count gets low enough, take it out of the routing table
  */
-void
+		void
 rtfree(struct rtentry *rt)
 {
-	struct radix_node_head *rnh;
+	dprint(("rtfree Start\n"));
+	struct ptree_node_head *rnh;
 
 	KASSERT(rt != NULL,("%s: NULL rt", __func__));
 	rnh = rt_tables_get_rnh(rt->rt_fibnum, rt_key(rt)->sa_family);
@@ -413,8 +413,8 @@
 	 */
 	RT_REMREF(rt);
 	if (rt->rt_refcnt > 0) {
-		log(LOG_DEBUG, "%s: %p has %d refs\n", __func__, rt, rt->rt_refcnt);
-		goto done;
+			log(LOG_DEBUG, "%s: %p has %d refs\n", __func__, rt, rt->rt_refcnt);
+			goto done;
 	}
 
 	/*
@@ -427,7 +427,7 @@
 	 * on the entry so that the code below reclaims the storage.
 	 */
 	if (rt->rt_refcnt == 0 && rnh->rnh_close)
-		rnh->rnh_close((struct radix_node *)rt, rnh);
+			rnh->rnh_close((struct ptree_node *)rt, rnh);
 
 	/*
 	 * If we are no longer "up" (and ref == 0)
@@ -435,41 +435,40 @@
 	 * with the route.
 	 */
 	if ((rt->rt_flags & RTF_UP) == 0) {
-		if (rt->rt_nodes->rn_flags & (RNF_ACTIVE | RNF_ROOT))
-			panic("rtfree 2");
-		/*
-		 * the rtentry must have been removed from the routing table
-		 * so it is represented in rttrash.. remove that now.
-		 */
-		V_rttrash--;
+			if (rt->rt_nodes->data == NULL)
+			/*
+			 * the rtentry must have been removed from the routing table
+			 * so it is represented in rttrash.. remove that now.
+			 */
+			V_rttrash--;
 #ifdef	DIAGNOSTIC
-		if (rt->rt_refcnt < 0) {
-			printf("rtfree: %p not freed (neg refs)\n", rt);
-			goto done;
-		}
+			if (rt->rt_refcnt < 0) 
+					goto done;
 #endif
-		/*
-		 * release references on items we hold them on..
-		 * e.g other routes and ifaddrs.
-		 */
-		if (rt->rt_ifa)
-			ifa_free(rt->rt_ifa);
-		/*
-		 * The key is separatly alloc'd so free it (see rt_setgate()).
-		 * This also frees the gateway, as they are always malloc'd
-		 * together.
-		 */
-		Free(rt_key(rt));
+			/*
+			 * release references on items we hold them on..
+			 * e.g other routes and ifaddrs.
+			 */
+			if (rt->rt_ifa)
+					ifa_free(rt->rt_ifa);
+			/*
+			 * The key is separatly alloc'd so free it (see rt_setgate()).
+			 * This also frees the gateway, as they are always malloc'd
+			 * together.
+			 */
+			Free(rt_key(rt));
 
-		/*
-		 * and the rtentry itself of course
-		 */
-		RT_LOCK_DESTROY(rt);
-		uma_zfree(V_rtzone, rt);
-		return;
+			/*
+			 * and the rtentry itself of course
+			 */
+			RT_LOCK_DESTROY(rt);
+			uma_zfree(V_rtzone, rt);
+			dprint(("rtfree End\n"));
+			return;
 	}
 done:
 	RT_UNLOCK(rt);
+	dprint(("rtfree End\n"));
 }
 
 
@@ -479,42 +478,42 @@
  * Normally called as a result of a routing redirect
  * message from the network layer.
  */
-void
+		void
 rtredirect(struct sockaddr *dst,
-	struct sockaddr *gateway,
-	struct sockaddr *netmask,
-	int flags,
-	struct sockaddr *src)
+				struct sockaddr *gateway,
+				struct sockaddr *netmask,
+				int flags,
+				struct sockaddr *src)
 {
 	rtredirect_fib(dst, gateway, netmask, flags, src, 0);
 }
 
-void
+		void
 rtredirect_fib(struct sockaddr *dst,
-	struct sockaddr *gateway,
-	struct sockaddr *netmask,
-	int flags,
-	struct sockaddr *src,
-	u_int fibnum)
+				struct sockaddr *gateway,
+				struct sockaddr *netmask,
+				int flags,
+				struct sockaddr *src,
+				u_int fibnum)
 {
 	struct rtentry *rt, *rt0 = NULL;
 	int error = 0;
 	short *stat = NULL;
 	struct rt_addrinfo info;
 	struct ifaddr *ifa;
-	struct radix_node_head *rnh;
+	struct ptree_node_head *rnh;
 
 	ifa = NULL;
 	rnh = rt_tables_get_rnh(fibnum, dst->sa_family);
 	if (rnh == NULL) {
-		error = EAFNOSUPPORT;
-		goto out;
+			error = EAFNOSUPPORT;
+			goto out;
 	}
 
 	/* verify the gateway is directly reachable */
 	if ((ifa = ifa_ifwithnet(gateway)) == NULL) {
-		error = ENETUNREACH;
-		goto out;
+			error = ENETUNREACH;
+			goto out;
 	}
 	rt = rtalloc1_fib(dst, 0, 0UL, fibnum);	/* NB: rt is locked */
 	/*
@@ -524,12 +523,12 @@
 	 * going down recently.
 	 */
 	if (!(flags & RTF_DONE) && rt &&
-	     (!sa_equal(src, rt->rt_gateway) || rt->rt_ifa != ifa))
-		error = EINVAL;
+					(!sa_equal(src, rt->rt_gateway) || rt->rt_ifa != ifa))
+			error = EINVAL;
 	else if (ifa_ifwithaddr_check(gateway))
-		error = EHOSTUNREACH;
+			error = EHOSTUNREACH;
 	if (error)
-		goto done;
+			goto done;
 	/*
 	 * Create a new entry if we just got back a wildcard entry
 	 * or the the lookup failed.  This is necessary for hosts
@@ -537,73 +536,73 @@
 	 * to dynamically build the routing tables.
 	 */
 	if (rt == NULL || (rt_mask(rt) && rt_mask(rt)->sa_len < 2))
-		goto create;
+			goto create;
 	/*
 	 * Don't listen to the redirect if it's
 	 * for a route to an interface.
 	 */
 	if (rt->rt_flags & RTF_GATEWAY) {
-		if (((rt->rt_flags & RTF_HOST) == 0) && (flags & RTF_HOST)) {
-			/*
-			 * Changing from route to net => route to host.
-			 * Create new route, rather than smashing route to net.
-			 */
-		create:
-			rt0 = rt;
-			rt = NULL;
-		
-			flags |=  RTF_GATEWAY | RTF_DYNAMIC;
-			bzero((caddr_t)&info, sizeof(info));
-			info.rti_info[RTAX_DST] = dst;
-			info.rti_info[RTAX_GATEWAY] = gateway;
-			info.rti_info[RTAX_NETMASK] = netmask;
-			info.rti_ifa = ifa;
-			info.rti_flags = flags;
-			if (rt0 != NULL)
-				RT_UNLOCK(rt0);	/* drop lock to avoid LOR with RNH */
-			error = rtrequest1_fib(RTM_ADD, &info, &rt, fibnum);
-			if (rt != NULL) {
-				RT_LOCK(rt);
-				if (rt0 != NULL)
-					EVENTHANDLER_INVOKE(route_redirect_event, rt0, rt, dst);
-				flags = rt->rt_flags;
-			}
-			if (rt0 != NULL)
-				RTFREE(rt0);
-			
-			stat = &V_rtstat.rts_dynamic;
-		} else {
-			struct rtentry *gwrt;
+			if (((rt->rt_flags & RTF_HOST) == 0) && (flags & RTF_HOST)) {
+					/*
+					 * Changing from route to net => route to host.
+					 * Create new route, rather than smashing route to net.
+					 */
+create:
+					rt0 = rt;
+					rt = NULL;
+
+					flags |=  RTF_GATEWAY | RTF_DYNAMIC;
+					bzero((caddr_t)&info, sizeof(info));
+					info.rti_info[RTAX_DST] = dst;
+					info.rti_info[RTAX_GATEWAY] = gateway;
+					info.rti_info[RTAX_NETMASK] = netmask;
+					info.rti_ifa = ifa;
+					info.rti_flags = flags;
+					if (rt0 != NULL)
+							RT_UNLOCK(rt0);	/* drop lock to avoid LOR with RNH */
+					error = rtrequest1_fib(RTM_ADD, &info, &rt, fibnum);
+					if (rt != NULL) {
+							RT_LOCK(rt);
+							if (rt0 != NULL)
+									EVENTHANDLER_INVOKE(route_redirect_event, rt0, rt, dst);
+							flags = rt->rt_flags;
+					}
+					if (rt0 != NULL)
+							RTFREE(rt0);
 
-			/*
-			 * Smash the current notion of the gateway to
-			 * this destination.  Should check about netmask!!!
-			 */
-			rt->rt_flags |= RTF_MODIFIED;
-			flags |= RTF_MODIFIED;
-			stat = &V_rtstat.rts_newgateway;
-			/*
-			 * add the key and gateway (in one malloc'd chunk).
-			 */
-			RT_UNLOCK(rt);
-			RADIX_NODE_HEAD_LOCK(rnh);
-			RT_LOCK(rt);
-			rt_setgate(rt, rt_key(rt), gateway);
-			gwrt = rtalloc1(gateway, 1, RTF_RNH_LOCKED);
-			RADIX_NODE_HEAD_UNLOCK(rnh);
-			EVENTHANDLER_INVOKE(route_redirect_event, rt, gwrt, dst);
-			RTFREE_LOCKED(gwrt);
-		}
+					stat = &V_rtstat.rts_dynamic;
+			} else {
+					struct rtentry *gwrt;
+
+					/*
+					 * Smash the current notion of the gateway to
+					 * this destination.  Should check about netmask!!!
+					 */
+					rt->rt_flags |= RTF_MODIFIED;
+					flags |= RTF_MODIFIED;
+					stat = &V_rtstat.rts_newgateway;
+					/*
+					 * add the key and gateway (in one malloc'd chunk).
+					 */
+					RT_UNLOCK(rt);
+					RADIX_NODE_HEAD_LOCK(rnh);
+					RT_LOCK(rt);
+					rt_setgate(rt, rt_key(rt), gateway);
+					gwrt = rtalloc1(gateway, 1, RTF_RNH_LOCKED);
+					RADIX_NODE_HEAD_UNLOCK(rnh);
+					EVENTHANDLER_INVOKE(route_redirect_event, rt, gwrt, dst);
+					RTFREE_LOCKED(gwrt);
+			}
 	} else
-		error = EHOSTUNREACH;
+			error = EHOSTUNREACH;
 done:
 	if (rt)
-		RTFREE_LOCKED(rt);
+			RTFREE_LOCKED(rt);
 out:
 	if (error)
-		V_rtstat.rts_badredirect++;
+			V_rtstat.rts_badredirect++;
 	else if (stat != NULL)
-		(*stat)++;
+			(*stat)++;
 	bzero((caddr_t)&info, sizeof(info));
 	info.rti_info[RTAX_DST] = dst;
 	info.rti_info[RTAX_GATEWAY] = gateway;
@@ -611,10 +610,10 @@
 	info.rti_info[RTAX_AUTHOR] = src;
 	rt_missmsg(RTM_REDIRECT, &info, flags, error);
 	if (ifa != NULL)
-		ifa_free(ifa);
+			ifa_free(ifa);
 }
 
-int
+		int
 rtioctl(u_long req, caddr_t data)
 {
 	return (rtioctl_fib(req, data, 0));
@@ -623,10 +622,9 @@
 /*
  * Routing table ioctl interface.
  */
-int
+		int
 rtioctl_fib(u_long req, caddr_t data, u_int fibnum)
 {
-
 	/*
 	 * If more ioctl commands are added here, make sure the proper
 	 * super-user checks are being performed because it is possible for
@@ -644,13 +642,13 @@
 /*
  * For both ifa_ifwithroute() routines, 'ifa' is returned referenced.
  */
-struct ifaddr *
+		struct ifaddr *
 ifa_ifwithroute(int flags, struct sockaddr *dst, struct sockaddr *gateway)
 {
 	return (ifa_ifwithroute_fib(flags, dst, gateway, 0));
 }
 
-struct ifaddr *
+		struct ifaddr *
 ifa_ifwithroute_fib(int flags, struct sockaddr *dst, struct sockaddr *gateway,
 				u_int fibnum)
 {
@@ -658,64 +656,64 @@
 	int not_found = 0;
 
 	if ((flags & RTF_GATEWAY) == 0) {
-		/*
-		 * If we are adding a route to an interface,
-		 * and the interface is a pt to pt link
-		 * we should search for the destination
-		 * as our clue to the interface.  Otherwise
-		 * we can use the local address.
-		 */
-		ifa = NULL;
-		if (flags & RTF_HOST)
-			ifa = ifa_ifwithdstaddr(dst);
-		if (ifa == NULL)
-			ifa = ifa_ifwithaddr(gateway);
+			/*
+			 * If we are adding a route to an interface,
+			 * and the interface is a pt to pt link
+			 * we should search for the destination
+			 * as our clue to the interface.  Otherwise
+			 * we can use the local address.
+			 */
+			ifa = NULL;
+			if (flags & RTF_HOST)
+					ifa = ifa_ifwithdstaddr(dst);
+			if (ifa == NULL)
+					ifa = ifa_ifwithaddr(gateway);
 	} else {
-		/*
-		 * If we are adding a route to a remote net
-		 * or host, the gateway may still be on the
-		 * other end of a pt to pt link.
-		 */
-		ifa = ifa_ifwithdstaddr(gateway);
+			/*
+			 * If we are adding a route to a remote net
+			 * or host, the gateway may still be on the
+			 * other end of a pt to pt link.
+			 */
+			ifa = ifa_ifwithdstaddr(gateway);
 	}
 	if (ifa == NULL)
-		ifa = ifa_ifwithnet(gateway);
+			ifa = ifa_ifwithnet(gateway);
 	if (ifa == NULL) {
-		struct rtentry *rt = rtalloc1_fib(gateway, 0, RTF_RNH_LOCKED, fibnum);
-		if (rt == NULL)
-			return (NULL);
-		/*
-		 * dismiss a gateway that is reachable only
-		 * through the default router
-		 */
-		switch (gateway->sa_family) {
-		case AF_INET:
-			if (satosin(rt_key(rt))->sin_addr.s_addr == INADDR_ANY)
-				not_found = 1;
-			break;
-		case AF_INET6:
-			if (IN6_IS_ADDR_UNSPECIFIED(&satosin6(rt_key(rt))->sin6_addr))
-				not_found = 1;
-			break;
-		default:
-			break;
-		}
-		if (!not_found && rt->rt_ifa != NULL) {
-			ifa = rt->rt_ifa;
-			ifa_ref(ifa);
-		}
-		RT_REMREF(rt);
-		RT_UNLOCK(rt);
-		if (not_found || ifa == NULL)
-			return (NULL);
+			struct rtentry *rt = rtalloc1_fib(gateway, 0, RTF_RNH_LOCKED, fibnum);
+			if (rt == NULL)
+					return (NULL);
+			/*
+			 * dismiss a gateway that is reachable only
+			 * through the default router
+			 */
+			switch (gateway->sa_family) {
+					case AF_INET:
+							if (satosin(rt_key(rt))->sin_addr.s_addr == INADDR_ANY)
+									not_found = 1;
+							break;
+					case AF_INET6:
+							if (IN6_IS_ADDR_UNSPECIFIED(&satosin6(rt_key(rt))->sin6_addr))
+									not_found = 1;
+							break;
+					default:
+							break;
+			}
+			if (!not_found && rt->rt_ifa != NULL) {
+					ifa = rt->rt_ifa;
+					ifa_ref(ifa);
+			}
+			RT_REMREF(rt);
+			RT_UNLOCK(rt);
+			if (not_found || ifa == NULL)
+					return (NULL);
 	}
 	if (ifa->ifa_addr->sa_family != dst->sa_family) {
-		struct ifaddr *oifa = ifa;
-		ifa = ifaof_ifpforaddr(dst, ifa->ifa_ifp);
-		if (ifa == NULL)
-			ifa = oifa;
-		else
-			ifa_free(oifa);
+			struct ifaddr *oifa = ifa;
+			ifa = ifaof_ifpforaddr(dst, ifa->ifa_ifp);
+			if (ifa == NULL)
+					ifa = oifa;
+			else
+					ifa_free(oifa);
 	}
 	return (ifa);
 }
@@ -724,30 +722,30 @@
  * Do appropriate manipulations of a routing tree given
  * all the bits of info needed
  */
-int
+		int
 rtrequest(int req,
-	struct sockaddr *dst,
-	struct sockaddr *gateway,
-	struct sockaddr *netmask,
-	int flags,
-	struct rtentry **ret_nrt)
+				struct sockaddr *dst,
+				struct sockaddr *gateway,
+				struct sockaddr *netmask,
+				int flags,
+				struct rtentry **ret_nrt)
 {
 	return (rtrequest_fib(req, dst, gateway, netmask, flags, ret_nrt, 0));
 }
 
-int
+		int
 rtrequest_fib(int req,
-	struct sockaddr *dst,
-	struct sockaddr *gateway,
-	struct sockaddr *netmask,
-	int flags,
-	struct rtentry **ret_nrt,
-	u_int fibnum)
+				struct sockaddr *dst,
+				struct sockaddr *gateway,
+				struct sockaddr *netmask,
+				int flags,
+				struct rtentry **ret_nrt,
+				u_int fibnum)
 {
 	struct rt_addrinfo info;
 
 	if (dst->sa_len == 0)
-		return(EINVAL);
+			return(EINVAL);
 
 	bzero((caddr_t)&info, sizeof(info));
 	info.rti_flags = flags;
@@ -768,7 +766,7 @@
 #define	ifpaddr	info->rti_info[RTAX_IFP]
 #define	flags	info->rti_flags
 
-int
+		int
 rt_getifa(struct rt_addrinfo *info)
 {
 	return (rt_getifa_fib(info, 0));
@@ -778,7 +776,7 @@
  * Look up rt_addrinfo for a specific fib.  Note that if rti_ifa is defined,
  * it will be referenced so the caller must free it.
  */
-int
+		int
 rt_getifa_fib(struct rt_addrinfo *info, u_int fibnum)
 {
 	struct ifaddr *ifa;
@@ -789,32 +787,32 @@
 	 * when protocol address is ambiguous.
 	 */
 	if (info->rti_ifp == NULL && ifpaddr != NULL &&
-	    ifpaddr->sa_family == AF_LINK &&
-	    (ifa = ifa_ifwithnet(ifpaddr)) != NULL) {
-		info->rti_ifp = ifa->ifa_ifp;
-		ifa_free(ifa);
+					ifpaddr->sa_family == AF_LINK &&
+					(ifa = ifa_ifwithnet(ifpaddr)) != NULL) {
+			info->rti_ifp = ifa->ifa_ifp;
+			ifa_free(ifa);
 	}
 	if (info->rti_ifa == NULL && ifaaddr != NULL)
-		info->rti_ifa = ifa_ifwithaddr(ifaaddr);
+			info->rti_ifa = ifa_ifwithaddr(ifaaddr);
 	if (info->rti_ifa == NULL) {
-		struct sockaddr *sa;
+			struct sockaddr *sa;
 
-		sa = ifaaddr != NULL ? ifaaddr :
-		    (gateway != NULL ? gateway : dst);
-		if (sa != NULL && info->rti_ifp != NULL)
-			info->rti_ifa = ifaof_ifpforaddr(sa, info->rti_ifp);
-		else if (dst != NULL && gateway != NULL)
-			info->rti_ifa = ifa_ifwithroute_fib(flags, dst, gateway,
-							fibnum);
-		else if (sa != NULL)
-			info->rti_ifa = ifa_ifwithroute_fib(flags, sa, sa,
-							fibnum);
+			sa = ifaaddr != NULL ? ifaaddr :
+					(gateway != NULL ? gateway : dst);
+			if (sa != NULL && info->rti_ifp != NULL)
+					info->rti_ifa = ifaof_ifpforaddr(sa, info->rti_ifp);
+			else if (dst != NULL && gateway != NULL)
+					info->rti_ifa = ifa_ifwithroute_fib(flags, dst, gateway,
+										fibnum);
+			else if (sa != NULL)
+					info->rti_ifa = ifa_ifwithroute_fib(flags, sa, sa,
+									fibnum);
 	}
 	if ((ifa = info->rti_ifa) != NULL) {
-		if (info->rti_ifp == NULL)
-			info->rti_ifp = ifa->ifa_ifp;
+			if (info->rti_ifp == NULL)
+					info->rti_ifp = ifa->ifa_ifp;
 	} else
-		error = ENETUNREACH;
+			error = ENETUNREACH;
 	return (error);
 }
 
@@ -822,11 +820,11 @@
  * Expunges references to a route that's about to be reclaimed.
  * The route must be locked.
  */
-int
+		int
 rtexpunge(struct rtentry *rt)
 {
-	struct radix_node *rn;
-	struct radix_node_head *rnh;
+	struct ptree_node *rn;
+	struct ptree_node_head *rnh;
 	struct ifaddr *ifa;
 	int error = 0;
 
@@ -836,7 +834,7 @@
 	rnh = rt_tables_get_rnh(rt->rt_fibnum, rt_key(rt)->sa_family);
 	RT_LOCK_ASSERT(rt);
 	if (rnh == NULL)
-		return (EAFNOSUPPORT);
+			return (EAFNOSUPPORT);
 	RADIX_NODE_HEAD_LOCK_ASSERT(rnh);
 #if 0
 	/*
@@ -852,13 +850,13 @@
 	 */
 	rn = rnh->rnh_deladdr(rt_key(rt), rt_mask(rt), rnh);
 	if (rn == NULL) {
-		error = ESRCH;
-		goto bad;
+			error = ESRCH;
+			goto bad;
 	}
 	KASSERT((rn->rn_flags & (RNF_ACTIVE | RNF_ROOT)) == 0,
-		("unexpected flags 0x%x", rn->rn_flags));
+					("unexpected flags 0x%x", rn->rn_flags));
 	KASSERT(rt == RNTORT(rn),
-		("lookup mismatch, rt %p rn %p", rt, rn));
+					("lookup mismatch, rt %p rn %p", rt, rn));
 
 	rt->rt_flags &= ~RTF_UP;
 
@@ -866,14 +864,14 @@
 	 * Give the protocol a chance to keep things in sync.
 	 */
 	if ((ifa = rt->rt_ifa) && ifa->ifa_rtrequest) {
-		struct rt_addrinfo info;
+			struct rt_addrinfo info;
 
-		bzero((caddr_t)&info, sizeof(info));
-		info.rti_flags = rt->rt_flags;
-		info.rti_info[RTAX_DST] = rt_key(rt);
-		info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
-		info.rti_info[RTAX_NETMASK] = rt_mask(rt);
-		ifa->ifa_rtrequest(RTM_DELETE, rt, &info);
+			bzero((caddr_t)&info, sizeof(info));
+			info.rti_flags = rt->rt_flags;
+			info.rti_info[RTAX_DST] = rt_key(rt);
+			info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
+			info.rti_info[RTAX_NETMASK] = rt_mask(rt);
+			ifa->ifa_rtrequest(RTM_DELETE, rt, &info);
 	}
 
 	/*
@@ -886,95 +884,95 @@
 }
 
 #ifdef RADIX_MPATH
-static int
+		static int
 rn_mpath_update(int req, struct rt_addrinfo *info,
-    struct radix_node_head *rnh, struct rtentry **ret_nrt)
+				struct ptree_node_head *rnh, struct rtentry **ret_nrt)
 {
 	/*
 	 * if we got multipath routes, we require users to specify
 	 * a matching RTAX_GATEWAY.
 	 */
 	struct rtentry *rt, *rto = NULL;
-	register struct radix_node *rn;
+	register struct ptree_node *rn;
 	int error = 0;
 
 	rn = rnh->rnh_matchaddr(dst, rnh);
 	if (rn == NULL)
-		return (ESRCH);
+			return (ESRCH);
 	rto = rt = RNTORT(rn);
 	rt = rt_mpath_matchgate(rt, gateway);
 	if (rt == NULL)
-		return (ESRCH);
+			return (ESRCH);
 	/*
 	 * this is the first entry in the chain
 	 */
 	if (rto == rt) {
-		rn = rn_mpath_next((struct radix_node *)rt);
-		/*
-		 * there is another entry, now it's active
-		 */
-		if (rn) {
-			rto = RNTORT(rn);
-			RT_LOCK(rto);
-			rto->rt_flags |= RTF_UP;
-			RT_UNLOCK(rto);
-		} else if (rt->rt_flags & RTF_GATEWAY) {
-			/*
-			 * For gateway routes, we need to 
-			 * make sure that we we are deleting
-			 * the correct gateway. 
-			 * rt_mpath_matchgate() does not 
-			 * check the case when there is only
-			 * one route in the chain.  
-			 */
-			if (gateway &&
-			    (rt->rt_gateway->sa_len != gateway->sa_len ||
-				memcmp(rt->rt_gateway, gateway, gateway->sa_len)))
-				error = ESRCH;
-			else {
-				/*
-				 * remove from tree before returning it
-				 * to the caller
-				 */
-				rn = rnh->rnh_deladdr(dst, netmask, rnh);
-				KASSERT(rt == RNTORT(rn), ("radix node disappeared"));
-				goto gwdelete;
+			rn = rn_mpath_next((struct ptree_node *)rt);
+			/*
+			 * there is another entry, now it's active
+			 */
+			if (rn) {
+					rto = RNTORT(rn);
+					RT_LOCK(rto);
+					rto->rt_flags |= RTF_UP;
+					RT_UNLOCK(rto);
+			} else if (rt->rt_flags & RTF_GATEWAY) {
+					/*
+					 * For gateway routes, we need to 
+					 * make sure that we we are deleting
+					 * the correct gateway. 
+					 * rt_mpath_matchgate() does not 
+					 * check the case when there is only
+					 * one route in the chain.  
+					 */
+					if (gateway &&
+									(rt->rt_gateway->sa_len != gateway->sa_len ||
+									 memcmp(rt->rt_gateway, gateway, gateway->sa_len)))
+							error = ESRCH;
+					else {
+							/*
+							 * remove from tree before returning it
+							 * to the caller
+							 */
+							rn = rnh->rnh_deladdr(dst, netmask, rnh);
+							KASSERT(rt == RNTORT(rn), ("radix node disappeared"));
+							goto gwdelete;
+					}
+
 			}
-			
-		}
-		/*
-		 * use the normal delete code to remove
-		 * the first entry
-		 */
-		if (req != RTM_DELETE) 
-			goto nondelete;
+			/*
+			 * use the normal delete code to remove
+			 * the first entry
+			 */
+			if (req != RTM_DELETE) 
+					goto nondelete;
 
-		error = ENOENT;
-		goto done;
+			error = ENOENT;
+			goto done;
 	}
-		
+
 	/*
 	 * if the entry is 2nd and on up
 	 */
 	if ((req == RTM_DELETE) && !rt_mpath_deldup(rto, rt))
-		panic ("rtrequest1: rt_mpath_deldup");
+			panic ("rtrequest1: rt_mpath_deldup");
 gwdelete:
 	RT_LOCK(rt);
 	RT_ADDREF(rt);
 	if (req == RTM_DELETE) {
-		rt->rt_flags &= ~RTF_UP;
-		/*
-		 * One more rtentry floating around that is not
-		 * linked to the routing table. rttrash will be decremented
-		 * when RTFREE(rt) is eventually called.
-		 */
-		V_rttrash++;
+			rt->rt_flags &= ~RTF_UP;
+			/*
+			 * One more rtentry floating around that is not
+			 * linked to the routing table. rttrash will be decremented
+			 * when RTFREE(rt) is eventually called.
+			 */
+			V_rttrash++;
 	}
-	
+
 nondelete:
 	if (req != RTM_DELETE)
-		panic("unrecognized request %d", req);
-	
+			panic("unrecognized request %d", req);
+
 
 	/*
 	 * If the caller wants it, then it can have it,
@@ -982,16 +980,16 @@
 	 * doing it.
 	 */
 	if (ret_nrt) {
-		*ret_nrt = rt;
-		RT_UNLOCK(rt);
+			*ret_nrt = rt;
+			RT_UNLOCK(rt);
 	} else
-		RTFREE_LOCKED(rt);
+			RTFREE_LOCKED(rt);
 done:
 	return (error);
 }
 #endif
 
-int
+		int
 rtrequest1_fib(int req, struct rt_addrinfo *info, struct rtentry **ret_nrt,
 				u_int fibnum)
 {
@@ -1000,262 +998,318 @@
 #ifdef FLOWTABLE
 	register struct rtentry *rt0;
 #endif
-	register struct radix_node *rn;
-	register struct radix_node_head *rnh;
+	struct ptree_node *rn;
+	register struct ptree_node_head *rnh;
 	struct ifaddr *ifa;
 	struct sockaddr *ndst;
-#define senderr(x) { error = x ; goto bad; }
+#define senderr(x) { error = x ; dprint(("goto bad %d\n",x)); goto bad; }
 
+	dprint(("rtrequest1_fib Start\n"));
 	KASSERT((fibnum < rt_numfibs), ("rtrequest1_fib: bad fibnum"));
 	if (dst->sa_family != AF_INET)	/* Only INET supports > 1 fib now */
-		fibnum = 0;
+			fibnum = 0;
 	/*
 	 * Find the correct routing tree to use for this Address Family
 	 */
 	rnh = rt_tables_get_rnh(fibnum, dst->sa_family);
 	if (rnh == NULL)
-		return (EAFNOSUPPORT);
+			return (EAFNOSUPPORT);
 	needlock = ((flags & RTF_RNH_LOCKED) == 0);
 	flags &= ~RTF_RNH_LOCKED;
 	if (needlock)
-		RADIX_NODE_HEAD_LOCK(rnh);
+			RADIX_NODE_HEAD_LOCK(rnh);
 	else
-		RADIX_NODE_HEAD_LOCK_ASSERT(rnh);
+			RADIX_NODE_HEAD_LOCK_ASSERT(rnh);
 	/*
 	 * If we are adding a host route then we don't want to put
 	 * a netmask in the tree, nor do we want to clone it.
 	 */
 	if (flags & RTF_HOST)
-		netmask = NULL;
+			netmask = NULL;
 
 	switch (req) {
-	case RTM_DELETE:
+		case RTM_DELETE:
+			dprint(("rtrequest1_fib case RTM_DELETE\n"));
 #ifdef RADIX_MPATH
-		if (rn_mpath_capable(rnh)) {
-			error = rn_mpath_update(req, info, rnh, ret_nrt);
+			if (rn_mpath_capable(rnh)) {
+				error = rn_mpath_update(req, info, rnh, ret_nrt);
+				/*
+				 * "bad" holds true for the success case
+				 * as well
+				 */
+				if (error != ENOENT)
+					goto bad;
+			}
+#endif
 			/*
-			 * "bad" holds true for the success case
-			 * as well
+			 * Remove the item from the tree and return it.
+			 * Complain if it is not there and do no more processing.
 			 */
-			if (error != ENOENT)
-				goto bad;
-		}
+			rn = rnh->rnh_deladdr(dst, info->rti_info[RTAX_GATEWAY], rnh);
+			if (rn == NULL)
+					senderr(ESRCH);
+#if 0
+			if (rn->rn_flags & (RNF_ACTIVE | RNF_ROOT))
+					panic ("rtrequest delete");
 #endif
-		/*
-		 * Remove the item from the tree and return it.
-		 * Complain if it is not there and do no more processing.
-		 */
-		rn = rnh->rnh_deladdr(dst, netmask, rnh);
-		if (rn == NULL)
-			senderr(ESRCH);
-		if (rn->rn_flags & (RNF_ACTIVE | RNF_ROOT))
-			panic ("rtrequest delete");
-		rt = RNTORT(rn);
-		RT_LOCK(rt);
-		RT_ADDREF(rt);
-		rt->rt_flags &= ~RTF_UP;
-
-		/*
-		 * give the protocol a chance to keep things in sync.
-		 */
-		if ((ifa = rt->rt_ifa) && ifa->ifa_rtrequest)
-			ifa->ifa_rtrequest(RTM_DELETE, rt, info);
-
-		/*
-		 * One more rtentry floating around that is not
-		 * linked to the routing table. rttrash will be decremented
-		 * when RTFREE(rt) is eventually called.
-		 */
-		V_rttrash++;
-
-		/*
-		 * If the caller wants it, then it can have it,
-		 * but it's up to it to free the rtentry as we won't be
-		 * doing it.
-		 */
-		if (ret_nrt) {
-			*ret_nrt = rt;
-			RT_UNLOCK(rt);
-		} else
-			RTFREE_LOCKED(rt);
-		break;
+			rt = RNTORT(rn);
+			RT_LOCK(rt);
+			RT_ADDREF(rt);
+			rt->rt_flags &= ~RTF_UP;
+			/*
+			 * give the protocol a chance to keep things in sync.
+			 */
+			if ((ifa = rt->rt_ifa) && ifa->ifa_rtrequest)
+					ifa->ifa_rtrequest(RTM_DELETE, rt, info);
+			/*
+			 * One more rtentry floating around that is not
+			 * linked to the routing table. rttrash will be decremented
+			 * when RTFREE(rt) is eventually called.
+			 */
+			V_rttrash++;
+			/*
+			 * If the caller wants it, then it can have it,
+			 * but it's up to it to free the rtentry as we won't be
+			 * doing it.
+			 */
+			if (ret_nrt) {
+					*ret_nrt = rt;
+					RT_UNLOCK(rt);
+			} else
+					RTFREE_LOCKED(rt);
+			break;
 	case RTM_RESOLVE:
-		/*
-		 * resolve was only used for route cloning
-		 * here for compat
-		 */
-		break;
+			/*
+			 * resolve was only used for route cloning
+			 * here for compat
+			 */
+			break;
 	case RTM_ADD:
-		if ((flags & RTF_GATEWAY) && !gateway)
-			senderr(EINVAL);
-		if (dst && gateway && (dst->sa_family != gateway->sa_family) && 
-		    (gateway->sa_family != AF_UNSPEC) && (gateway->sa_family != AF_LINK))
-			senderr(EINVAL);
-
-		if (info->rti_ifa == NULL) {
-			error = rt_getifa_fib(info, fibnum);
-			if (error)
-				senderr(error);
-		} else
-			ifa_ref(info->rti_ifa);
-		ifa = info->rti_ifa;
-		rt = uma_zalloc(V_rtzone, M_NOWAIT | M_ZERO);
-		if (rt == NULL) {
-			if (ifa != NULL)
-				ifa_free(ifa);
-			senderr(ENOBUFS);
-		}
-		RT_LOCK_INIT(rt);
-		rt->rt_flags = RTF_UP | flags;
-		rt->rt_fibnum = fibnum;
+			dprint(("rtrequest1_fib case RTM_ADD\n"));
+			if ((flags & RTF_GATEWAY) && !gateway)
+					senderr(EINVAL);
+			if (dst && gateway && 
+			(dst->sa_family != gateway->sa_family) &&
+			(gateway->sa_family != AF_UNSPEC) && 
+			(gateway->sa_family != AF_LINK) )
+					senderr(EINVAL);
+			if (info->rti_ifa == NULL) {
+				error = rt_getifa_fib(info, fibnum);
+				if (error)
+						senderr(error);
+			} else
+				ifa_ref(info->rti_ifa);
+				
+			ifa = info->rti_ifa;
+			rt = uma_zalloc(V_rtzone, M_NOWAIT | M_ZERO);
+			if (rt == NULL) {
+					if (ifa != NULL)
+							ifa_free(ifa);
+					senderr(ENOBUFS);
+			}
+			RT_LOCK_INIT(rt);
+			rt->rt_flags = RTF_UP | flags;
+			rt->rt_fibnum = fibnum;
 		/*
 		 * Add the gateway. Possibly re-malloc-ing the storage for it
 		 * 
 		 */
-		RT_LOCK(rt);
-		if ((error = rt_setgate(rt, dst, gateway)) != 0) {
-			RT_LOCK_DESTROY(rt);
-			if (ifa != NULL)
-				ifa_free(ifa);
-			uma_zfree(V_rtzone, rt);
-			senderr(error);
-		}
-
+			RT_LOCK(rt);
+			RT_LOCK_ASSERT(rt);
+			int dlen = SA_SIZE(dst), glen = SA_SIZE(gateway);
+			dprint(("rtrequest1_fib: dlen[%d] glen[%d]\n",dlen,glen));
+			caddr_t new;
+			R_Zalloc(new, caddr_t, dlen + glen);
+			if (new == NULL){
+				RT_LOCK_DESTROY(rt);
+				if (ifa != NULL)
+					ifa_free(ifa);
+				uma_zfree(V_rtzone, rt);
+				senderr(ENOBUFS);
+			}
+			bcopy(dst, new, dlen);
+			if(rt->rt_gateway == NULL || glen > SA_SIZE(rt->rt_gateway))
+				rt->rt_gateway = (struct sockaddr *)(new + dlen);
+			bcopy(gateway, rt->rt_gateway, glen);
+
+#ifdef DEBUG		
+			struct sockaddr *gate = (struct sockaddr *)rt->rt_gateway;
+			unsigned char *str = (unsigned char *)gate;
+			int i;
+			printf("rtrequest1_fib: gateway ");
+			for(i=0;i < glen;i++)
+				printf("%d.",str[i]);
+			printf("/%d\n",glen*8);
+			
+			char name[NI_MAXHOST] = { 0 }, ntop[NI_MAXHOST] = { 0 };
+			int ecode = getnameinfo(&gate, glen, ntop, sizeof(ntop), NULL, 0, NI_NUMERICHOST);
+			if (ecode != 0) {
+				warnx ("%s", gai_strerror(ecode) );
+			} else {
+				ecode = getnameinfo( sa, len, name, sizeof(name), NULL, 0, NI_NAMEREQD);
+			}
+			printf ("%s : %s\n", name, ntop);
+#endif	
+			
+#if 0
+				if ((error = rt_setgate(rt, dst, gateway)) != 0) {
+						RT_LOCK_DESTROY(rt);
+						if (ifa != NULL)
+								ifa_free(ifa);
+						uma_zfree(V_rtzone, rt);
+						senderr(error);
+				}
+#endif
 		/*
 		 * point to the (possibly newly malloc'd) dest address.
 		 */
-		ndst = (struct sockaddr *)rt_key(rt);
-
+			ndst = (struct sockaddr *)new;
 		/*
 		 * make sure it contains the value we want (masked if needed).
 		 */
-		if (netmask) {
-			rt_maskedcopy(dst, ndst, netmask);
-		} else
-			bcopy(dst, ndst, dst->sa_len);
-
+			if (netmask) {
+					rt_maskedcopy(dst, ndst, netmask);
+			} else
+					bcopy(dst, ndst, dst->sa_len);
 		/*
 		 * We use the ifa reference returned by rt_getifa_fib().
 		 * This moved from below so that rnh->rnh_addaddr() can
 		 * examine the ifa and  ifa->ifa_ifp if it so desires.
 		 */
-		rt->rt_ifa = ifa;
-		rt->rt_ifp = ifa->ifa_ifp;
-		rt->rt_rmx.rmx_weight = 1;
-
+			rt->rt_ifa = ifa;
+			rt->rt_ifp = ifa->ifa_ifp;
+			rt->rt_rmx.rmx_weight = 1;
 #ifdef RADIX_MPATH
 		/* do not permit exactly the same dst/mask/gw pair */
-		if (rn_mpath_capable(rnh) &&
-			rt_mpath_conflict(rnh, rt, netmask)) {
-			if (rt->rt_ifa) {
-				ifa_free(rt->rt_ifa);
+			if (rn_mpath_capable(rnh) &&
+				rt_mpath_conflict(rnh, rt, netmask)) {
+					if (rt->rt_ifa) {
+							ifa_free(rt->rt_ifa);
+					}
+					Free(rt_key(rt));
+					RT_LOCK_DESTROY(rt);
+					uma_zfree(V_rtzone, rt);
+					senderr(EEXIST);
 			}
-			Free(rt_key(rt));
-			RT_LOCK_DESTROY(rt);
-			uma_zfree(V_rtzone, rt);
-			senderr(EEXIST);
-		}
 #endif
-
+#ifdef PTREE_MPATH
+		/* do not permit exactly the same dst/mask/gw pair */
+			if (ptree_mpath_capable(rnh) &&
+				rt_mpath_conflict(rnh, rt, ndst)) {
+					if (rt->rt_ifa) {
+							ifa_free(rt->rt_ifa);
+					}
+					RT_LOCK_DESTROY(rt);
+					uma_zfree(V_rtzone, rt);
+					senderr(EEXIST);
+			}
+			/* init mpath_array */
+			rt->mpath_array = 0;
+#endif
 #ifdef FLOWTABLE
-		rt0 = NULL;
+			rt0 = NULL;
 		/* XXX
 		 * "flow-table" only support IPv4 at the moment.
 		 */
 #ifdef INET
-		if (dst->sa_family == AF_INET) {
-			rn = rnh->rnh_matchaddr(dst, rnh);
-			if (rn && ((rn->rn_flags & RNF_ROOT) == 0)) {
-				struct sockaddr *mask;
-				u_char *m, *n;
-				int len;
-				
-				/*
-				 * compare mask to see if the new route is
-				 * more specific than the existing one
-				 */
-				rt0 = RNTORT(rn);
-				RT_LOCK(rt0);
-				RT_ADDREF(rt0);
-				RT_UNLOCK(rt0);
-				/*
-				 * A host route is already present, so 
-				 * leave the flow-table entries as is.
-				 */
-				if (rt0->rt_flags & RTF_HOST) {
-					RTFREE(rt0);
-					rt0 = NULL;
-				} else if (!(flags & RTF_HOST) && netmask) {
-					mask = rt_mask(rt0);
-					len = mask->sa_len;
-					m = (u_char *)mask;
-					n = (u_char *)netmask;
-					while (len-- > 0) {
-						if (*n != *m)
-							break;
-						n++;
-						m++;
+			if (dst->sa_family == AF_INET) {
+					rn = rnh->rnh_matchaddr(dst, rnh);
+					if (rn && ((rn->rn_flags & RNF_ROOT) == 0)) {
+							struct sockaddr *mask;
+							u_char *m, *n;
+							int len;
+							/*
+							 * compare mask to see if the new route is
+							 * more specific than the existing one
+							 */
+							rt0 = RNTORT(rn);
+							RT_LOCK(rt0);
+							RT_ADDREF(rt0);
+							RT_UNLOCK(rt0);
+							/*
+							 * A host route is already present, so 
+							 * leave the flow-table entries as is.
+							 */
+							if (rt0->rt_flags & RTF_HOST) {
+									RTFREE(rt0);
+									rt0 = NULL;
+							} else if (!(flags & RTF_HOST) && netmask) {
+									mask = rt_mask(rt0);
+									len = mask->sa_len;
+									m = (u_char *)mask;
+									n = (u_char *)netmask;
+									while (len-- > 0) {
+											if (*n != *m)
+													break;
+											n++;
+											m++;
+									}
+									if (len == 0 || (*n < *m)) {
+											RTFREE(rt0);
+											rt0 = NULL;
+									}
+							}
 					}
-					if (len == 0 || (*n < *m)) {
-						RTFREE(rt0);
-						rt0 = NULL;
-					}
-				}
 			}
-		}
-#endif
-#endif
-
-		/* XXX mtu manipulation will be done in rnh_addaddr -- itojun */
-		rn = rnh->rnh_addaddr(ndst, netmask, rnh, rt->rt_nodes);
-		/*
-		 * If it still failed to go into the tree,
-		 * then un-make it (this should be a function)
-		 */
-		if (rn == NULL) {
-			if (rt->rt_ifa)
-				ifa_free(rt->rt_ifa);
-			Free(rt_key(rt));
-			RT_LOCK_DESTROY(rt);
-			uma_zfree(V_rtzone, rt);
+#endif /* INET */
+#endif /* FLOWTABLE */
+	/* XXX mtu manipulation will be done in rnh_addaddr -- itojun */
+			rn = rnh->rnh_addaddr(ndst, netmask, rnh,
+						   (struct ptree_node *)rt/*&rt->rt_nodes*/);
+			rn->data = rt;
+			rt->rt_nodes = rn;
+			/*
+			 * If it still failed to go into the tree,
+			 * then un-make it (this should be a function)
+			 */
+			if (rn == NULL) {
+					if (rt->rt_ifa)
+							ifa_free(rt->rt_ifa);
+					Free(rt_key(rt));
+					RT_LOCK_DESTROY(rt);
+					uma_zfree(V_rtzone, rt);
 #ifdef FLOWTABLE
-			if (rt0 != NULL)
-				RTFREE(rt0);
+					if (rt0 != NULL)
+							RTFREE(rt0);
 #endif
-			senderr(EEXIST);
-		} 
+					senderr(EEXIST);
+			} 
 #ifdef FLOWTABLE
-		else if (rt0 != NULL) {
+			else if (rt0 != NULL) {
 #ifdef INET
-			flowtable_route_flush(V_ip_ft, rt0);
+					flowtable_route_flush(V_ip_ft, rt0);
 #endif
-			RTFREE(rt0);
-		}
+					RTFREE(rt0);
+			}
 #endif
-
-		/*
-		 * If this protocol has something to add to this then
-		 * allow it to do that as well.
-		 */
-		if (ifa->ifa_rtrequest)
-			ifa->ifa_rtrequest(req, rt, info);
-
-		/*
-		 * actually return a resultant rtentry and
-		 * give the caller a single reference.
-		 */
-		if (ret_nrt) {
-			*ret_nrt = rt;
-			RT_ADDREF(rt);
-		}
-		RT_UNLOCK(rt);
-		break;
+			/*
+			 * If this protocol has something to add to this then
+			 * allow it to do that as well.
+			 */
+			if (ifa->ifa_rtrequest){
+					dprint(("rtrequest1_fib: ifa_rtrequest\n"));
+					ifa->ifa_rtrequest(req, rt, info);
+			}
+			/*
+			 * actually return a resultant rtentry and
+			 * give the caller a single reference.
+			 */
+			if (ret_nrt) {
+				*ret_nrt = rt;
+				RT_ADDREF(rt);
+			}
+			RT_UNLOCK(rt);
+			break;
 	default:
-		error = EOPNOTSUPP;
-	}
+			error = EOPNOTSUPP;
+}
 bad:
 	if (needlock)
-		RADIX_NODE_HEAD_UNLOCK(rnh);
+			RADIX_NODE_HEAD_UNLOCK(rnh);
+	if (DEBUG && !error){
+		dprint(("rt_request1_fib End:"));
+		debug_tree_print(rnh);
+	}
 	return (error);
 #undef senderr
 }
@@ -1267,20 +1321,19 @@
 #undef ifpaddr
 #undef flags
 
-int
+		int
 rt_setgate(struct rtentry *rt, struct sockaddr *dst, struct sockaddr *gate)
 {
 	/* XXX dst may be overwritten, can we move this to below */
 	int dlen = SA_SIZE(dst), glen = SA_SIZE(gate);
 #ifdef INVARIANTS
-	struct radix_node_head *rnh;
+	struct ptree_node_head *rnh;
 
 	rnh = rt_tables_get_rnh(rt->rt_fibnum, dst->sa_family);
 #endif
-
 	RT_LOCK_ASSERT(rt);
 	RADIX_NODE_HEAD_LOCK_ASSERT(rnh);
-	
+
 	/*
 	 * Prepare to store the gateway in rt->rt_gateway.
 	 * Both dst and gateway are stored one after the other in the same
@@ -1289,33 +1342,32 @@
 	 * Otherwise, malloc a new block and update the 'dst' address.
 	 */
 	if (rt->rt_gateway == NULL || glen > SA_SIZE(rt->rt_gateway)) {
-		caddr_t new;
-
-		R_Malloc(new, caddr_t, dlen + glen);
-		if (new == NULL)
-			return ENOBUFS;
-		/*
-		 * XXX note, we copy from *dst and not *rt_key(rt) because
-		 * rt_setgate() can be called to initialize a newly
-		 * allocated route entry, in which case rt_key(rt) == NULL
-		 * (and also rt->rt_gateway == NULL).
-		 * Free()/free() handle a NULL argument just fine.
-		 */
-		bcopy(dst, new, dlen);
-		Free(rt_key(rt));	/* free old block, if any */
-		rt_key(rt) = (struct sockaddr *)new;
-		rt->rt_gateway = (struct sockaddr *)(new + dlen);
+			caddr_t new;
+			
+			R_Malloc(new, caddr_t, dlen + glen);
+			if (new == NULL)
+					return ENOBUFS;
+			/*
+			 * XXX note, we copy from *dst and not *rt_key(rt) because
+			 * rt_setgate() can be called to initialize a newly
+			 * allocated route entry, in which case rt_key(rt) == NULL
+			 * (and also rt->rt_gateway == NULL).
+			 * Free()/free() handle a NULL argument just fine.
+			 */
+			bcopy(dst, new, dlen);
+			Free(rt_key(rt));	/* free old block, if any */
+			rt_key(rt) = (struct sockaddr *)new;
+			rt->rt_gateway = (struct sockaddr *)(new + dlen);
 	}
 
 	/*
 	 * Copy the new gateway value into the memory chunk.
 	 */
 	bcopy(gate, rt->rt_gateway, glen);
-
 	return (0);
 }
 
-static void
+		static void
 rt_maskedcopy(struct sockaddr *src, struct sockaddr *dst, struct sockaddr *netmask)
 {
 	register u_char *cp1 = (u_char *)src;
@@ -1327,11 +1379,11 @@
 	*cp2++ = *cp1++; *cp2++ = *cp1++; /* copies sa_len & sa_family */
 	cp3 += 2;
 	if (cplim > cplim2)
-		cplim = cplim2;
+			cplim = cplim2;
 	while (cp2 < cplim)
-		*cp2++ = *cp1++ & *cp3++;
+			*cp2++ = *cp1++ & *cp3++;
 	if (cp2 < cplim2)
-		bzero((caddr_t)cp2, (unsigned)(cplim2 - cp2));
+			bzero((caddr_t)cp2, (unsigned)(cplim2 - cp2));
 }
 
 /*
@@ -1339,7 +1391,7 @@
  * for an interface.
  */
 #define _SOCKADDR_TMPSIZE 128 /* Not too big.. kernel stack size is limited */
-static inline  int
+		static inline  int
 rtinit1(struct ifaddr *ifa, int cmd, int flags, int fibnum)
 {
 	struct sockaddr *dst;
@@ -1352,30 +1404,32 @@
 	int didwork = 0;
 	int a_failure = 0;
 	static struct sockaddr_dl null_sdl = {sizeof(null_sdl), AF_LINK};
+	dprint(("rtinit1 Start\n"));
 
 	if (flags & RTF_HOST) {
-		dst = ifa->ifa_dstaddr;
-		netmask = NULL;
+			dst = ifa->ifa_dstaddr;
+			netmask = NULL;
 	} else {
-		dst = ifa->ifa_addr;
-		netmask = ifa->ifa_netmask;
+			dst = ifa->ifa_addr;
+			netmask = ifa->ifa_netmask;
 	}
 	if ( dst->sa_family != AF_INET)
-		fibnum = 0;
+			fibnum = 0;
 	if (fibnum == -1) {
-		if (rt_add_addr_allfibs == 0 && cmd == (int)RTM_ADD) {
-			startfib = endfib = curthread->td_proc->p_fibnum;
-		} else {
-			startfib = 0;
-			endfib = rt_numfibs - 1;
-		}
+			if (rt_add_addr_allfibs == 0 && cmd == (int)RTM_ADD) {
+					startfib = endfib = curthread->td_proc->p_fibnum;
+			} else {
+					startfib = 0;
+					endfib = rt_numfibs - 1;
+			}
 	} else {
-		KASSERT((fibnum < rt_numfibs), ("rtinit1: bad fibnum"));
-		startfib = fibnum;
-		endfib = fibnum;
+			KASSERT((fibnum < rt_numfibs), ("rtinit1: bad fibnum"));
+			startfib = fibnum;
+			endfib = fibnum;
+	}
+	if (dst->sa_len == 0){
+			return(EINVAL);
 	}
-	if (dst->sa_len == 0)
-		return(EINVAL);
 
 	/*
 	 * If it's a delete, check that if it exists,
@@ -1384,16 +1438,16 @@
 	 * be confusing at best and possibly worse.
 	 */
 	if (cmd == RTM_DELETE) {
-		/*
-		 * It's a delete, so it should already exist..
-		 * If it's a net, mask off the host bits
-		 * (Assuming we have a mask)
-		 * XXX this is kinda inet specific..
-		 */
-		if (netmask != NULL) {
-			rt_maskedcopy(dst, (struct sockaddr *)tempbuf, netmask);
-			dst = (struct sockaddr *)tempbuf;
-		}
+			/*
+			 * It's a delete, so it should already exist..
+			 * If it's a net, mask off the host bits
+			 * (Assuming we have a mask)
+			 * XXX this is kinda inet specific..
+			 */
+			if (netmask != NULL) {
+					rt_maskedcopy(dst, (struct sockaddr *)tempbuf, netmask);
+					dst = (struct sockaddr *)tempbuf;
+			}
 	}
 	/*
 	 * Now go through all the requested tables (fibs) and do the
@@ -1404,141 +1458,140 @@
 	 * independent parts and protocol dependent parts.
 	 */
 	for ( fibnum = startfib; fibnum <= endfib; fibnum++) {
-		if (cmd == RTM_DELETE) {
-			struct radix_node_head *rnh;
-			struct radix_node *rn;
-			/*
-			 * Look up an rtentry that is in the routing tree and
-			 * contains the correct info.
-			 */
-			rnh = rt_tables_get_rnh(fibnum, dst->sa_family);
-			if (rnh == NULL)
-				/* this table doesn't exist but others might */
-				continue;
-			RADIX_NODE_HEAD_LOCK(rnh);
-#ifdef RADIX_MPATH
-			if (rn_mpath_capable(rnh)) {
-
-				rn = rnh->rnh_matchaddr(dst, rnh);
-				if (rn == NULL) 
-					error = ESRCH;
-				else {
-					rt = RNTORT(rn);
+			if (cmd == RTM_DELETE) {
+					struct ptree_node_head *rnh;
+					struct ptree_node *rn;
 					/*
-					 * for interface route the
-					 * rt->rt_gateway is sockaddr_intf
-					 * for cloning ARP entries, so
-					 * rt_mpath_matchgate must use the
-					 * interface address
+					 * Look up an rtentry that is in the routing tree and
+					 * contains the correct info.
 					 */
-					rt = rt_mpath_matchgate(rt,
-					    ifa->ifa_addr);
-					if (!rt) 
-						error = ESRCH;
-				}
-			}
-			else
+					rnh = rt_tables_get_rnh(fibnum, dst->sa_family);
+					if (rnh == NULL)
+							/* this table doesn't exist but others might */
+							continue;
+					RADIX_NODE_HEAD_LOCK(rnh);
+#ifdef RADIX_MPATH
+					if (rn_mpath_capable(rnh)) {
+
+							rn = rnh->rnh_matchaddr(dst, rnh);
+							if (rn == NULL) 
+									error = ESRCH;
+							else {
+									rt = RNTORT(rn);
+									/*
+									 * for interface route the
+									 * rt->rt_gateway is sockaddr_intf
+									 * for cloning ARP entries, so
+									 * rt_mpath_matchgate must use the
+									 * interface address
+									 */
+									rt = rt_mpath_matchgate(rt,
+													ifa->ifa_addr);
+									if (!rt) 
+											error = ESRCH;
+							}
+					}
+					else
 #endif
-			rn = rnh->rnh_lookup(dst, netmask, rnh);
-			error = (rn == NULL ||
-			    (rn->rn_flags & RNF_ROOT) ||
-			    RNTORT(rn)->rt_ifa != ifa ||
-			    !sa_equal((struct sockaddr *)rn->rn_key, dst));
-			RADIX_NODE_HEAD_UNLOCK(rnh);
-			if (error) {
-				/* this is only an error if bad on ALL tables */
-				continue;
+							rn = rnh->rnh_lookup(dst->sa_data, (int)*(const u_char *)netmask->sa_data, rnh->pnh_treetop);
+					error = (rn == NULL ||
+									RNTORT(rn)->rt_ifa != ifa ||
+									!sa_equal((struct sockaddr *)rn->key, dst));
+					RADIX_NODE_HEAD_UNLOCK(rnh);
+					if (error) {
+							/* this is only an error if bad on ALL tables */
+							continue;
+					}
 			}
-		}
-		/*
-		 * Do the actual request
-		 */
-		bzero((caddr_t)&info, sizeof(info));
-		info.rti_ifa = ifa;
-		info.rti_flags = flags | ifa->ifa_flags;
-		info.rti_info[RTAX_DST] = dst;
-		/* 
-		 * doing this for compatibility reasons
-		 */
-		if (cmd == RTM_ADD)
-			info.rti_info[RTAX_GATEWAY] =
-			    (struct sockaddr *)&null_sdl;
-		else
-			info.rti_info[RTAX_GATEWAY] = ifa->ifa_addr;
-		info.rti_info[RTAX_NETMASK] = netmask;
-		error = rtrequest1_fib(cmd, &info, &rt, fibnum);
-		if (error == 0 && rt != NULL) {
 			/*
-			 * notify any listening routing agents of the change
+			 * Do the actual request
 			 */
-			RT_LOCK(rt);
-#ifdef RADIX_MPATH
-			/*
-			 * in case address alias finds the first address
-			 * e.g. ifconfig bge0 192.103.54.246/24
-			 * e.g. ifconfig bge0 192.103.54.247/24
-			 * the address set in the route is 192.103.54.246
-			 * so we need to replace it with 192.103.54.247
-			 */
-			if (memcmp(rt->rt_ifa->ifa_addr,
-			    ifa->ifa_addr, ifa->ifa_addr->sa_len)) {
-				ifa_free(rt->rt_ifa);
-				ifa_ref(ifa);
-				rt->rt_ifp = ifa->ifa_ifp;
-				rt->rt_ifa = ifa;
-			}
-#endif
+			bzero((caddr_t)&info, sizeof(info));
+			info.rti_ifa = ifa;
+			info.rti_flags = flags | ifa->ifa_flags;
+			info.rti_info[RTAX_DST] = dst;
 			/* 
 			 * doing this for compatibility reasons
 			 */
-			if (cmd == RTM_ADD) {
-			    ((struct sockaddr_dl *)rt->rt_gateway)->sdl_type  =
-				rt->rt_ifp->if_type;
-			    ((struct sockaddr_dl *)rt->rt_gateway)->sdl_index =
-				rt->rt_ifp->if_index;
-			}
-			rt_newaddrmsg(cmd, ifa, error, rt);
-			if (cmd == RTM_DELETE) {
-				/*
-				 * If we are deleting, and we found an entry,
-				 * then it's been removed from the tree..
-				 * now throw it away.
-				 */
-				RTFREE_LOCKED(rt);
-			} else {
-				if (cmd == RTM_ADD) {
+			if (cmd == RTM_ADD)
+					info.rti_info[RTAX_GATEWAY] =
+							(struct sockaddr *)&null_sdl;
+			else
+					info.rti_info[RTAX_GATEWAY] = ifa->ifa_addr;
+			info.rti_info[RTAX_NETMASK] = netmask;
+			error = rtrequest1_fib(cmd, &info, &rt, fibnum);
+			if (error == 0 && rt != NULL) {
 					/*
-					 * We just wanted to add it..
-					 * we don't actually need a reference.
+					 * notify any listening routing agents of the change
 					 */
-					RT_REMREF(rt);
-				}
-				RT_UNLOCK(rt);
+					RT_LOCK(rt);
+#ifdef RADIX_MPATH
+					/*
+					 * in case address alias finds the first address
+					 * e.g. ifconfig bge0 192.103.54.246/24
+					 * e.g. ifconfig bge0 192.103.54.247/24
+					 * the address set in the route is 192.103.54.246
+					 * so we need to replace it with 192.103.54.247
+					 */
+					if (memcmp(rt->rt_ifa->ifa_addr,
+											ifa->ifa_addr, ifa->ifa_addr->sa_len)) {
+							ifa_free(rt->rt_ifa);
+							ifa_ref(ifa);
+							rt->rt_ifp = ifa->ifa_ifp;
+							rt->rt_ifa = ifa;
+					}
+#endif
+					/* 
+					 * doing this for compatibility reasons
+					 */
+					if (cmd == RTM_ADD) {
+							((struct sockaddr_dl *)rt->rt_gateway)->sdl_type  =
+									rt->rt_ifp->if_type;
+							((struct sockaddr_dl *)rt->rt_gateway)->sdl_index =
+									rt->rt_ifp->if_index;
+					}
+					rt_newaddrmsg(cmd, ifa, error, rt);
+					if (cmd == RTM_DELETE) {
+							/*
+							 * If we are deleting, and we found an entry,
+							 * then it's been removed from the tree..
+							 * now throw it away.
+							 */
+							RTFREE_LOCKED(rt);
+					} else {
+							if (cmd == RTM_ADD) {
+									/*
+									 * We just wanted to add it..
+									 * we don't actually need a reference.
+									 */
+									RT_REMREF(rt);
+							}
+							RT_UNLOCK(rt);
+					}
+					didwork = 1;
 			}
-			didwork = 1;
-		}
-		if (error)
-			a_failure = error;
+			if (error)
+					a_failure = error;
 	}
 	if (cmd == RTM_DELETE) {
-		if (didwork) {
-			error = 0;
-		} else {
-			/* we only give an error if it wasn't in any table */
-			error = ((flags & RTF_HOST) ?
-			    EHOSTUNREACH : ENETUNREACH);
-		}
+			if (didwork) {
+					error = 0;
+			} else {
+					/* we only give an error if it wasn't in any table */
+					error = ((flags & RTF_HOST) ?
+									EHOSTUNREACH : ENETUNREACH);
+			}
 	} else {
-		if (a_failure) {
-			/* return an error if any of them failed */
-			error = a_failure;
-		}
+			if (a_failure) {
+					/* return an error if any of them failed */
+					error = a_failure;
+			}
 	}
 	return (error);
 }
 
 /* special one for inet internal use. may not use. */
-int
+		int
 rtinit_fib(struct ifaddr *ifa, int cmd, int flags)
 {
 	return (rtinit1(ifa, cmd, flags, -1));
@@ -1548,19 +1601,19 @@
  * Set up a routing table entry, normally
  * for an interface.
  */
-int
+		int
 rtinit(struct ifaddr *ifa, int cmd, int flags)
 {
 	struct sockaddr *dst;
 	int fib = 0;
 
 	if (flags & RTF_HOST) {
-		dst = ifa->ifa_dstaddr;
+			dst = ifa->ifa_dstaddr;
 	} else {
-		dst = ifa->ifa_addr;
+			dst = ifa->ifa_addr;
 	}
 
 	if (dst->sa_family == AF_INET)
-		fib = -1;
+			fib = -1;
 	return (rtinit1(ifa, cmd, flags, fib));
 }
