--- route.c.orig	2005-02-24 13:50:32.000000000 +0900
+++ route.c	2010-12-21 22:31:46.000000000 +0900
@@ -38,6 +38,7 @@
 #include "opt_route.h"
 #include "opt_mrouting.h"
 #include "opt_mpath.h"
+#include "opt_ptree.h"
 
 #include <sys/param.h>
 #include <sys/systm.h>
@@ -58,15 +59,15 @@
 #include <net/vnet.h>
 #include <net/flowtable.h>
 
-#ifdef RADIX_MPATH
-#include <net/radix_mpath.h>
-#endif
-
 #include <netinet/in.h>
 #include <netinet/ip_mroute.h>
 
 #include <vm/uma.h>
 
+#ifdef DEBUG
+#include <sys/types.h>
+#endif
+
 u_int rt_numfibs = RT_NUMFIBS;
 SYSCTL_INT(_net, OID_AUTO, fibs, CTLFLAG_RD, &rt_numfibs, 0, "");
 /*
@@ -88,7 +89,7 @@
     &rt_add_addr_allfibs, 0, "");
 TUNABLE_INT("net.add_addr_allfibs", &rt_add_addr_allfibs);
 
-VNET_DEFINE(struct radix_node_head *, rt_tables);
+VNET_DEFINE(struct ptree_node_head *, rt_tables);
 static VNET_DEFINE(uma_zone_t, rtzone);		/* Routing table UMA zone. */
 VNET_DEFINE(int, rttrash);		/* routes not in table but not freed */
 VNET_DEFINE(struct rtstat, rtstat);
@@ -114,7 +115,7 @@
  * But because there are a lot of assumptions in this conversion,
  * do not cast explicitly, but always use the macro below.
  */
-#define RNTORT(p)	((struct rtentry *)(p))
+#define RNTORT(p)	((struct rtentry *)(p->data))
 
 #if 0
 /* default fib for tunnels to use */
@@ -139,28 +140,26 @@
 SYSCTL_PROC(_net, OID_AUTO, my_fibnum, CTLTYPE_INT|CTLFLAG_RD,
             NULL, 0, &sysctl_my_fibnum, "I", "default FIB of caller");
 
-static __inline struct radix_node_head **
+		static __inline struct ptree_node_head **
 rt_tables_get_rnh_ptr(int table, int fam)
 {
-	struct radix_node_head **rnh;
+	struct ptree_node_head **rnh;
 
-	KASSERT(table >= 0 && table < rt_numfibs, ("%s: table out of bounds.",
-	    __func__));
+	KASSERT(table >= 0 && table < rt_numfibs, ("%s: table out of bounds.", __func__));
 	KASSERT(fam >= 0 && fam < (AF_MAX+1), ("%s: fam out of bounds.",
 	    __func__));
 
 	/* rnh is [fib=0][af=0]. */
-	rnh = (struct radix_node_head **)V_rt_tables;
+	rnh = (struct ptree_node_head **)V_rt_tables;
 	/* Get the offset to the requested table and fam. */
 	rnh += table * (AF_MAX+1) + fam;
 
 	return (rnh);
 }
 
-struct radix_node_head *
+		struct ptree_node_head *
 rt_tables_get_rnh(int table, int fam)
 {
-
 	return (*rt_tables_get_rnh_ptr(table, fam));
 }
 
@@ -177,7 +175,7 @@
 		rt_numfibs = RT_MAXFIBS;
 	if (rt_numfibs == 0)
 		rt_numfibs = 1;
-	rn_init();	/* initialize all zeroes, all ones, mask table */
+	ptree_init();
 }
 SYSINIT(route_init, SI_SUB_PROTO_DOMAIN, SI_ORDER_THIRD, route_init, 0);
 
@@ -185,20 +183,20 @@
 vnet_route_init(const void *unused __unused)
 {
 	struct domain *dom;
-	struct radix_node_head **rnh;
+	struct ptree_node_head **rnh;
 	int table;
 	int fam;
 
 	V_rt_tables = malloc(rt_numfibs * (AF_MAX+1) *
-	    sizeof(struct radix_node_head *), M_RTABLE, M_WAITOK|M_ZERO);
+			sizeof(struct ptree_node_head *), M_RTABLE, M_WAITOK|M_ZERO);
 
 	V_rtzone = uma_zcreate("rtentry", sizeof(struct rtentry), NULL, NULL,
 	    NULL, NULL, UMA_ALIGN_PTR, 0);
 	for (dom = domains; dom; dom = dom->dom_next) {
 		if (dom->dom_rtattach)  {
 			for  (table = 0; table < rt_numfibs; table++) {
-				if ( (fam = dom->dom_family) == AF_INET ||
-				    table == 0) {
+							if ( (fam = dom->dom_family) == AF_INET 
+											|| table == 0) {
  			        	/* for now only AF_INET has > 1 table */
 					/* XXX MRT 
 					 * rtattach will be also called
@@ -229,7 +227,7 @@
 	int table;
 	int fam;
 	struct domain *dom;
-	struct radix_node_head **rnh;
+	struct ptree_node_head **rnh;
 
 	for (dom = domains; dom; dom = dom->dom_next) {
 		if (dom->dom_rtdetach) {
@@ -330,13 +328,14 @@
 rtalloc1_fib(struct sockaddr *dst, int report, u_long ignflags,
 		    u_int fibnum)
 {
-	struct radix_node_head *rnh;
+	struct ptree_node_head *rnh;
 	struct rtentry *rt;
-	struct radix_node *rn;
+	struct ptree_node *rn;
 	struct rtentry *newrt;
 	struct rt_addrinfo info;
 	int err = 0, msgtype = RTM_MISS;
 	int needlock;
+	dprint(("rtalloc1_fib Start\n"));
 
 	KASSERT((fibnum < rt_numfibs), ("rtalloc1_fib: bad fibnum"));
 	if (dst->sa_family != AF_INET)	/* Only INET supports > 1 fib now */
@@ -358,7 +357,7 @@
 		RADIX_NODE_HEAD_LOCK_ASSERT(rnh);
 #endif
 	rn = rnh->rnh_matchaddr(dst, rnh);
-	if (rn && ((rn->rn_flags & RNF_ROOT) == 0)) {
+	if (rn/* && ((rn->rn_flags & RNF_ROOT) == 0)*/) {
 		newrt = rt = RNTORT(rn);
 		RT_LOCK(newrt);
 		RT_ADDREF(newrt);
@@ -389,6 +387,7 @@
 done:
 	if (newrt)
 		RT_LOCK_ASSERT(newrt);
+	dprint(("rtalloc1_End\n"));
 	return (newrt);
 }
 
@@ -399,7 +398,8 @@
 void
 rtfree(struct rtentry *rt)
 {
-	struct radix_node_head *rnh;
+	dprint(("rtfree Start: rt[%p]\n",rt));
+	struct ptree_node_head *rnh;
 
 	KASSERT(rt != NULL,("%s: NULL rt", __func__));
 	rnh = rt_tables_get_rnh(rt->rt_fibnum, rt_key(rt)->sa_family);
@@ -427,7 +427,7 @@
 	 * on the entry so that the code below reclaims the storage.
 	 */
 	if (rt->rt_refcnt == 0 && rnh->rnh_close)
-		rnh->rnh_close((struct radix_node *)rt, rnh);
+			rnh->rnh_close((struct ptree_node *)rt, rnh);
 
 	/*
 	 * If we are no longer "up" (and ref == 0)
@@ -435,18 +435,15 @@
 	 * with the route.
 	 */
 	if ((rt->rt_flags & RTF_UP) == 0) {
-		if (rt->rt_nodes->rn_flags & (RNF_ACTIVE | RNF_ROOT))
-			panic("rtfree 2");
+			if (rt->rt_nodes->data == NULL)
 		/*
 		 * the rtentry must have been removed from the routing table
 		 * so it is represented in rttrash.. remove that now.
 		 */
 		V_rttrash--;
 #ifdef	DIAGNOSTIC
-		if (rt->rt_refcnt < 0) {
-			printf("rtfree: %p not freed (neg refs)\n", rt);
+			if (rt->rt_refcnt < 0) 
 			goto done;
-		}
 #endif
 		/*
 		 * release references on items we hold them on..
@@ -466,10 +463,12 @@
 		 */
 		RT_LOCK_DESTROY(rt);
 		uma_zfree(V_rtzone, rt);
+			dprint(("rtfree End\n"));
 		return;
 	}
 done:
 	RT_UNLOCK(rt);
+	dprint(("rtfree End: done\n"));
 }
 
 
@@ -502,7 +501,7 @@
 	short *stat = NULL;
 	struct rt_addrinfo info;
 	struct ifaddr *ifa;
-	struct radix_node_head *rnh;
+	struct ptree_node_head *rnh;
 
 	ifa = NULL;
 	rnh = rt_tables_get_rnh(fibnum, dst->sa_family);
@@ -825,8 +823,8 @@
 int
 rtexpunge(struct rtentry *rt)
 {
-	struct radix_node *rn;
-	struct radix_node_head *rnh;
+	struct ptree_node *rn;
+	struct ptree_node_head *rnh;
 	struct ifaddr *ifa;
 	int error = 0;
 
@@ -888,14 +886,14 @@
 #ifdef RADIX_MPATH
 static int
 rn_mpath_update(int req, struct rt_addrinfo *info,
-    struct radix_node_head *rnh, struct rtentry **ret_nrt)
+				struct ptree_node_head *rnh, struct rtentry **ret_nrt)
 {
 	/*
 	 * if we got multipath routes, we require users to specify
 	 * a matching RTAX_GATEWAY.
 	 */
 	struct rtentry *rt, *rto = NULL;
-	register struct radix_node *rn;
+	register struct ptree_node *rn;
 	int error = 0;
 
 	rn = rnh->rnh_matchaddr(dst, rnh);
@@ -909,7 +907,7 @@
 	 * this is the first entry in the chain
 	 */
 	if (rto == rt) {
-		rn = rn_mpath_next((struct radix_node *)rt);
+			rn = rn_mpath_next((struct ptree_node *)rt);
 		/*
 		 * there is another entry, now it's active
 		 */
@@ -1000,12 +998,13 @@
 #ifdef FLOWTABLE
 	register struct rtentry *rt0;
 #endif
-	register struct radix_node *rn;
-	register struct radix_node_head *rnh;
+	struct ptree_node *rn;
+	register struct ptree_node_head *rnh;
 	struct ifaddr *ifa;
 	struct sockaddr *ndst;
-#define senderr(x) { error = x ; goto bad; }
+#define senderr(x) { error = x ; dprint(("goto bad %d\n",x)); goto bad; }
 
+	dprint(("rtrequest1_fib Start\n"));
 	KASSERT((fibnum < rt_numfibs), ("rtrequest1_fib: bad fibnum"));
 	if (dst->sa_family != AF_INET)	/* Only INET supports > 1 fib now */
 		fibnum = 0;
@@ -1030,6 +1029,7 @@
 
 	switch (req) {
 	case RTM_DELETE:
+			dprint(("rtrequest1_fib case RTM_DELETE\n"));
 #ifdef RADIX_MPATH
 		if (rn_mpath_capable(rnh)) {
 			error = rn_mpath_update(req, info, rnh, ret_nrt);
@@ -1045,11 +1045,13 @@
 		 * Remove the item from the tree and return it.
 		 * Complain if it is not there and do no more processing.
 		 */
-		rn = rnh->rnh_deladdr(dst, netmask, rnh);
+			rn = rnh->rnh_deladdr(dst, info->rti_info[RTAX_GATEWAY], rnh);
 		if (rn == NULL)
 			senderr(ESRCH);
+#if 0
 		if (rn->rn_flags & (RNF_ACTIVE | RNF_ROOT))
 			panic ("rtrequest delete");
+#endif
 		rt = RNTORT(rn);
 		RT_LOCK(rt);
 		RT_ADDREF(rt);
@@ -1086,12 +1085,14 @@
 		 */
 		break;
 	case RTM_ADD:
+			dprint(("rtrequest1_fib case RTM_ADD\n"));
 		if ((flags & RTF_GATEWAY) && !gateway)
 			senderr(EINVAL);
-		if (dst && gateway && (dst->sa_family != gateway->sa_family) && 
-		    (gateway->sa_family != AF_UNSPEC) && (gateway->sa_family != AF_LINK))
+			if (dst && gateway && 
+			(dst->sa_family != gateway->sa_family) &&
+			(gateway->sa_family != AF_UNSPEC) && 
+			(gateway->sa_family != AF_LINK) )
 			senderr(EINVAL);
-
 		if (info->rti_ifa == NULL) {
 			error = rt_getifa_fib(info, fibnum);
 			if (error)
@@ -1113,6 +1115,24 @@
 		 * 
 		 */
 		RT_LOCK(rt);
+			RT_LOCK_ASSERT(rt);
+			int dlen = SA_SIZE(dst), glen = SA_SIZE(gateway);
+			caddr_t new;
+
+			R_Zalloc(new, caddr_t, dlen + glen);
+			if (new == NULL){
+				RT_LOCK_DESTROY(rt);
+				if (ifa != NULL)
+					ifa_free(ifa);
+				uma_zfree(V_rtzone, rt);
+				senderr(ENOBUFS);
+			}
+			bcopy(dst, new, dlen);
+			if(rt->rt_gateway == NULL || glen > SA_SIZE(rt->rt_gateway))
+				rt->rt_gateway = (struct sockaddr *)(new + dlen);
+			bcopy(gateway, rt->rt_gateway, glen);
+
+#if 0
 		if ((error = rt_setgate(rt, dst, gateway)) != 0) {
 			RT_LOCK_DESTROY(rt);
 			if (ifa != NULL)
@@ -1120,12 +1140,11 @@
 			uma_zfree(V_rtzone, rt);
 			senderr(error);
 		}
-
+#endif
 		/*
 		 * point to the (possibly newly malloc'd) dest address.
 		 */
-		ndst = (struct sockaddr *)rt_key(rt);
-
+			ndst = (struct sockaddr *)new;
 		/*
 		 * make sure it contains the value we want (masked if needed).
 		 */
@@ -1156,7 +1173,20 @@
 			senderr(EEXIST);
 		}
 #endif
-
+#ifdef PTREE_MPATH
+		/* do not permit exactly the same dst/mask/gw pair */
+			if (ptree_mpath_capable(rnh) &&
+				rt_mpath_conflict(rnh, rt, ndst)) {
+					if (rt->rt_ifa) {
+							ifa_free(rt->rt_ifa);
+					}
+					RT_LOCK_DESTROY(rt);
+					uma_zfree(V_rtzone, rt);
+					senderr(EEXIST);
+			}
+			/* init mpath_array */
+			rt->mpath_array = 0;
+#endif
 #ifdef FLOWTABLE
 		rt0 = NULL;
 		/* XXX
@@ -1203,11 +1232,11 @@
 				}
 			}
 		}
-#endif
-#endif
-
+#endif /* INET */
+#endif /* FLOWTABLE */
 		/* XXX mtu manipulation will be done in rnh_addaddr -- itojun */
-		rn = rnh->rnh_addaddr(ndst, netmask, rnh, rt->rt_nodes);
+			rn = rnh->rnh_addaddr(ndst, netmask, rnh,
+						   (struct ptree_node *)rt);
 		/*
 		 * If it still failed to go into the tree,
 		 * then un-make it (this should be a function)
@@ -1256,6 +1283,10 @@
 bad:
 	if (needlock)
 		RADIX_NODE_HEAD_UNLOCK(rnh);
+	if (DEBUG){
+		dprint(("rt_request1_fib End:"));
+		debug_tree_print(rnh);
+	}
 	return (error);
 #undef senderr
 }
@@ -1273,7 +1304,7 @@
 	/* XXX dst may be overwritten, can we move this to below */
 	int dlen = SA_SIZE(dst), glen = SA_SIZE(gate);
 #ifdef INVARIANTS
-	struct radix_node_head *rnh;
+	struct ptree_node_head *rnh;
 
 	rnh = rt_tables_get_rnh(rt->rt_fibnum, dst->sa_family);
 #endif
@@ -1352,6 +1381,7 @@
 	int didwork = 0;
 	int a_failure = 0;
 	static struct sockaddr_dl null_sdl = {sizeof(null_sdl), AF_LINK};
+	dprint(("rtinit1 Start\n"));
 
 	if (flags & RTF_HOST) {
 		dst = ifa->ifa_dstaddr;
@@ -1374,8 +1404,9 @@
 		startfib = fibnum;
 		endfib = fibnum;
 	}
-	if (dst->sa_len == 0)
+	if (dst->sa_len == 0){
 		return(EINVAL);
+	}
 
 	/*
 	 * If it's a delete, check that if it exists,
@@ -1405,8 +1436,8 @@
 	 */
 	for ( fibnum = startfib; fibnum <= endfib; fibnum++) {
 		if (cmd == RTM_DELETE) {
-			struct radix_node_head *rnh;
-			struct radix_node *rn;
+					struct ptree_node_head *rnh;
+					struct ptree_node *rn;
 			/*
 			 * Look up an rtentry that is in the routing tree and
 			 * contains the correct info.
@@ -1439,11 +1470,10 @@
 			}
 			else
 #endif
-			rn = rnh->rnh_lookup(dst, netmask, rnh);
+							rn = rnh->rnh_lookup(dst->sa_data, (int)*(const u_char *)netmask->sa_data, rnh->pnh_treetop);
 			error = (rn == NULL ||
-			    (rn->rn_flags & RNF_ROOT) ||
 			    RNTORT(rn)->rt_ifa != ifa ||
-			    !sa_equal((struct sockaddr *)rn->rn_key, dst));
+									!sa_equal((struct sockaddr *)rn->key, dst));
 			RADIX_NODE_HEAD_UNLOCK(rnh);
 			if (error) {
 				/* this is only an error if bad on ALL tables */
